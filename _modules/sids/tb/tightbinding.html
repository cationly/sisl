

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sids.tb.tightbinding</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="None" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> sids
          

          
          </a>

          
            
            
              <div class="version">
                0..
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="simple">
</ul>
<ul class="simple">
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">sids</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>sids.tb.tightbinding</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sids.tb.tightbinding</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Tight-binding class to create tight-binding models.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="kn">as</span> <span class="nn">sli</span>


<span class="kn">from</span> <span class="nn">sids</span> <span class="kn">import</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">Quaternion</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;TightBinding&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="TightBinding"><a class="viewcode-back" href="../../../sids.tb.tightbinding.html#sids.tb.tightbinding.TightBinding">[docs]</a><span class="k">class</span> <span class="nc">TightBinding</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The defining tight-binding model for constructing models</span>
<span class="sd">    in python for easy manipulation in tbtrans.</span>

<span class="sd">    This class allows the creation of sparse tight-binding</span>
<span class="sd">    models on extreme scales.</span>

<span class="sd">    Any tight-binding model has an underlying geometry which</span>
<span class="sd">    is a requirement for the construction of a full tight-binding</span>
<span class="sd">    parameter set.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># The order of the Energy</span>
    <span class="c"># I.e. whether energy should be in other units than Ry</span>
    <span class="c"># This conversion is made: [eV] ** _E_order</span>
    <span class="n">_E_order</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">geom</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create tight-binding model from geometry</span>

<span class="sd">        Initializes a tight-binding model using the ``geom`` object</span>
<span class="sd">        as the underlying geometry for the tight-binding parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geom</span> <span class="o">=</span> <span class="n">geom</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c">######### Definitions of overrides ############</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns number of non-zero elements in the model &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nnzs</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Representation of the tight-binding model &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">__repr__</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Number of non-zero elements {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return tight-binding parameters for the index</span>

<span class="sd">        Returns the tight-binding parameters for the index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c"># We allow the retrieval of the full row</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">ind</span><span class="p">:</span><span class="n">ind</span><span class="o">+</span><span class="n">n</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">[</span><span class="n">ind</span><span class="p">:</span><span class="n">ind</span><span class="o">+</span><span class="n">n</span><span class="p">,:]</span>
        
        <span class="c"># It must be both row and column</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="n">j</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># this is a zero element</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the attributes from the underlying geometry</span>
<span class="sd">        </span>
<span class="sd">        Any attribute not found in the tight-binding model will</span>
<span class="sd">        be looked up in the underlying geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="p">,</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Sparse creation of the sparsity pattern</span>

<span class="sd">        Override set item for slicing operations and enables easy </span>
<span class="sd">        setting of tight-binding parameters in a sparse matrix</span>

<span class="sd">        It does allow fancy slicing in both dimensions with limited usability</span>
<span class="sd">        </span>
<span class="sd">        Ok, it is not pretty, it is not fast, but it works!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># unpack index</span>
        <span class="n">i</span> <span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">key</span>
        <span class="c"># Copy over the values of the tight-binding model</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c"># Recursively handle index,index = val</span>
            <span class="c"># designators.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">return</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c"># step pointer of all above this</span>
        <span class="n">ptr</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c"># Create the column indices in a strict manner</span>
        <span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">j</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">lj</span> <span class="o">=</span> <span class="n">jj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ncol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Checks whether any values in either array exists</span>
            <span class="c"># if so we remove those from the jj</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">jj</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">ptr</span><span class="p">:</span><span class="n">ptr</span><span class="o">+</span><span class="n">ncol</span><span class="p">],</span><span class="n">assume_unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="c"># Here we truncate jj to the &quot;new&quot; values,</span>
            <span class="c"># this allows us to both overwrite and add new values to the</span>
            <span class="c"># sparsity pattern (simultaneously)</span>
            <span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">jj</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">lj</span> <span class="o">=</span> <span class="n">jj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c"># the values corresponding to idx already exists,</span>
            <span class="c"># we overwrite that value</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">Integral</span><span class="p">):</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">ptr</span><span class="p">:</span><span class="n">ptr</span><span class="o">+</span><span class="n">ncol</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">[</span><span class="n">ptr</span><span class="o">+</span><span class="n">ix</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># remember that idx is the intersection values</span>
                <span class="k">for</span> <span class="n">ij</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
                    <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ij</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">ptr</span><span class="p">:</span><span class="n">ptr</span><span class="o">+</span><span class="n">ncol</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">[</span><span class="n">ptr</span><span class="o">+</span><span class="n">ix</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">v</span>

            <span class="c"># if no new values are left we return immediately</span>
            <span class="k">if</span> <span class="n">lj</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">ncol</span> <span class="o">+</span> <span class="n">lj</span><span class="p">:</span>
            <span class="c"># Ensure that it is not-set as finalized</span>
            <span class="c"># There is no need to set it all the time.</span>
            <span class="c"># Simply because the first call to finalize </span>
            <span class="c"># will reduce the sparsity pattern, which </span>
            <span class="c"># on first expansion calls this part.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c"># Expand size of the sparsity pattern</span>
            <span class="c"># We add 10 new elements on each extension</span>
            <span class="c"># This may be too reductionists, however, </span>
            <span class="c"># it should happen rarely</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+=</span> <span class="mi">10</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span><span class="n">ptr</span><span class="o">+</span><span class="n">ncol</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">,</span><span class="n">ptr</span><span class="o">+</span><span class="n">ncol</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c"># Step to the placement of the new values</span>
        <span class="n">ptr</span> <span class="o">+=</span> <span class="n">ncol</span>
        <span class="c"># set current value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">ptr</span><span class="p">:</span><span class="n">ptr</span><span class="o">+</span><span class="n">lj</span><span class="p">]</span>   <span class="o">=</span> <span class="n">jj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">[</span><span class="n">ptr</span><span class="p">:</span><span class="n">ptr</span><span class="o">+</span><span class="n">lj</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="c"># Append the new columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">lj</span>
        <span class="c"># Increment number of non-zero elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nnzs</span> <span class="o">+=</span> <span class="n">lj</span>

    <span class="c">############# DONE creating easy overrides #################</span>

<div class="viewcode-block" id="TightBinding.reset"><a class="viewcode-back" href="../../../sids.tb.tightbinding.html#sids.tb.tightbinding.TightBinding.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The sparsity pattern is cleaned and every thing </span>
<span class="sd">        is reset. </span>

<span class="sd">        The object will be the same as if it had been</span>
<span class="sd">        initialized with the same geometry as it were</span>
<span class="sd">        created with.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># I know that this is not the most efficient way to</span>
        <span class="c"># access a C-array, however, for constructing a</span>
        <span class="c"># sparse pattern, it should be faster if memory elements</span>
        <span class="c"># are closer... </span>
        <span class="c"># Hence, this choice of having H and S like this</span>

        <span class="c"># We check the first atom and its neighbours, we then</span>
        <span class="c"># select max(5,len(nc) * 4)</span>
        <span class="k">if</span> <span class="n">nc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span>

        <span class="c"># Reset the sparsity pattern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="c"># Create the interstitial pointer for each orbital</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nc</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span> <span class="o">-</span> <span class="n">nc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nnzs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        
        <span class="c"># Denote the tight-binding model as _not_ finalized</span>
        <span class="c"># Before saving, or anything being done, it _has_ to be</span>
        <span class="c"># finalized.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># Initialize TB size</span>
        <span class="c"># NOTE, this is not zeroed!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="TightBinding.construct"><a class="viewcode-back" href="../../../sids.tb.tightbinding.html#sids.tb.tightbinding.TightBinding.construct">[docs]</a>    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dR</span><span class="p">,</span><span class="n">param</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Automatically construct the tight-binding model based on `dR` and associated hopping integrals `param`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dR : array_like</span>
<span class="sd">           radii parameters for tight-binding parameters.</span>
<span class="sd">           Must have same length as `param` or one less.</span>
<span class="sd">           If one less it will be extended with `dR[0]/100`</span>
<span class="sd">        param : array_like</span>
<span class="sd">           tight-binding parameters corresponding to the `dR` </span>
<span class="sd">           ranges. `param[0,:]` are the tight-binding parameter</span>
<span class="sd">           for the all atoms within `dR[0]` of each atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dR</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">dR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">100</span><span class="p">,</span><span class="n">dR</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dR</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">dR</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&quot;Length of `dR` and `param` must be the same &quot;</span>
                              <span class="s">&quot;or `dR` one shorter than `param`. &quot;</span>
                              <span class="s">&quot;One tight-binding parameter for each radii.&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&quot;Number of parameters &quot;</span>
                              <span class="s">&quot;for each element is not 2. &quot;</span>
                              <span class="s">&quot;You must make len(param[0] == 2.&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">lasto</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">((</span><span class="s">&quot;Automatically setting a tight-binding model &quot;</span>
                           <span class="s">&quot;for systems with atoms having more than 1 &quot;</span>
                           <span class="s">&quot;orbital is not adviced. Please do it your-self.&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">:</span>
            <span class="c"># there is no need to do anything complex</span>
            <span class="c"># for small systems</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="p">:</span>
                <span class="c"># Find atoms close to `ia`</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">dR</span> <span class="o">=</span> <span class="n">R</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">param</span><span class="p">):</span>
                    <span class="c"># Set the tight-binding parameters</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
                    
            <span class="k">return</span> <span class="bp">self</span>
        
        <span class="c"># check how many atoms are within the standard 10 dR</span>
        <span class="c"># range of some random atom.</span>
        <span class="n">ia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># default block iterator</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">dR</span>
        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">dR</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="mi">10</span><span class="p">))</span>
        
        <span class="c"># Convert to 1000 atoms spherical radii</span>
        <span class="n">iR</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">d</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">/</span> <span class="n">na</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>

        <span class="c"># Do the loop</span>
        <span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">iter_block</span><span class="p">(</span><span class="n">iR</span> <span class="o">=</span> <span class="n">iR</span><span class="p">):</span>
            <span class="c"># Loop the atoms inside</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ias</span><span class="p">:</span>
                <span class="c"># Find atoms close to `ia`</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">dR</span> <span class="o">=</span> <span class="n">R</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">param</span><span class="p">):</span>
                    <span class="c"># Set the tight-binding parameters</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>

        <span class="k">return</span> <span class="bp">self</span>

        </div>
<div class="viewcode-block" id="TightBinding.finalize"><a class="viewcode-back" href="../../../sids.tb.tightbinding.html#sids.tb.tightbinding.TightBinding.finalize">[docs]</a>    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Finalizes the tight-binding model</span>

<span class="sd">        Finalizes the tight-binding model so that no new sparse</span>
<span class="sd">        elements can be added. </span>

<span class="sd">        Sparse elements can still be changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span><span class="p">:</span> <span class="k">return</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[:</span><span class="n">ptr</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ptr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;You cannot have two hoppings between the same &#39;</span><span class="o">+</span>
                             <span class="s">&#39;orbitals, something has went terribly wrong.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&quot;You have changed the geometry in the TightBinding &quot;</span> 
                              <span class="s">&quot;object, this is not allowed.&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># We truncate all the connections</span>
            <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">):</span>
                <span class="n">cptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">]</span>
                <span class="c"># Update actual pointer position</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span>
                <span class="n">no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">io</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">no</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span> <span class="c"># no non-assigned elements</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">ptr</span><span class="p">:</span><span class="n">ptr</span><span class="o">+</span><span class="n">no</span><span class="p">]</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">cptr</span><span class="p">:</span><span class="n">cptr</span><span class="o">+</span><span class="n">no</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">[</span><span class="n">ptr</span><span class="p">:</span><span class="n">ptr</span><span class="o">+</span><span class="n">no</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">[</span><span class="n">cptr</span><span class="p">:</span><span class="n">cptr</span><span class="o">+</span><span class="n">no</span><span class="p">,:]</span>
                <span class="c"># we also assert no two connections</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">ptr</span><span class="p">:</span><span class="n">ptr</span><span class="o">+</span><span class="n">no</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">no</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;You cannot have two hoppings between the same &#39;</span><span class="o">+</span>
                                     <span class="s">&#39;orbitals ({}), something has went terribly wrong.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">io</span><span class="p">))</span>
                <span class="n">ptr</span> <span class="o">+=</span> <span class="n">no</span>
        
        <span class="c"># Correcting the size of the pointer array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span>
        <span class="k">if</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nnzs</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_nnzs</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Final size in the tight-binding finalization &#39;</span><span class="o">+</span>
                             <span class="s">&#39;went wrong.&#39;</span><span class="p">)</span>
        
        <span class="c"># Truncate values to correct size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_nnzs</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_nnzs</span><span class="p">]</span>
        
        <span class="c"># Sort the indices, this is not strictly required, but</span>
        <span class="c"># it should speed up things.</span>
        <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">):</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">]</span>
            <span class="n">no</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">io</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">no</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
            <span class="c"># Sort the indices</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">ptr</span><span class="p">:</span><span class="n">ptr</span><span class="o">+</span><span class="n">no</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">ptr</span><span class="p">:</span><span class="n">ptr</span><span class="o">+</span><span class="n">no</span><span class="p">]</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">ptr</span><span class="o">+</span><span class="n">si</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">[</span><span class="n">ptr</span><span class="p">:</span><span class="n">ptr</span><span class="o">+</span><span class="n">no</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">[</span><span class="n">ptr</span><span class="o">+</span><span class="n">si</span><span class="p">,:]</span>

        <span class="c"># Check that the couplings are symmetric</span>
        <span class="n">TB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">TB</span><span class="o">.</span><span class="n">nnz</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="n">TB</span><span class="o">+</span><span class="n">TB</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">nnz</span>
        <span class="k">if</span> <span class="n">t1</span> <span class="o">!=</span> <span class="n">t2</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Tight-binding model does not retain symmetric couplings, this might be problematic: nnz(H) = {}, nnz(H+H^T) = {}.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">),</span> <span class="ne">UserWarning</span><span class="p">)</span> 
        <span class="k">del</span> <span class="n">TB</span>
    
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nnzs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns number of non-zero elements in the tight-binding model &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nnzs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">no</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns number of orbitals as used when the object was created &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no</span>


<div class="viewcode-block" id="TightBinding.tocsr"><a class="viewcode-back" href="../../../sids.tb.tightbinding.html#sids.tb.tightbinding.TightBinding.tocsr">[docs]</a>    <span class="k">def</span> <span class="nf">tocsr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns ``scipy.sparse`` matrices for the tight-binding model</span>

<span class="sd">        Returns a CSR sparse matrix for both the Hamiltonian</span>
<span class="sd">        and the overlap matrix using the scipy package.</span>
<span class="sd">        </span>
<span class="sd">        This method depends on scipy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Ensure completeness</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>

        <span class="c"># Create csr sparse formats.</span>
        <span class="c"># We import here as the user might not want to</span>
        <span class="c"># rely on this feature.</span>
        <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
        
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">no_s</span><span class="p">),</span>
                  <span class="s">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="o">.</span><span class="n">dtype</span> <span class="p">}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">),</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">csr_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">),</span><span class="o">**</span><span class="n">kw</span><span class="p">),</span> \
                        <span class="n">csr_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_TB</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ptr</span><span class="p">),</span><span class="o">**</span><span class="n">kw</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="c"># Setup the Hamiltonian for this k-point</span>
            <span class="n">Hfull</span><span class="p">,</span> <span class="n">Sfull</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>

            <span class="c"># Create k-space Hamiltonian</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
            
            <span class="c"># Get the reciprocal lattice vectors dotted with k</span>
            <span class="n">rcell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcell</span>
            <span class="n">kr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rcell</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">2.</span>
            <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">n_s</span><span class="p">):</span>
                <span class="n">isc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">si</span><span class="p">,:]</span>
                <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">kr</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span><span class="n">isc</span><span class="p">)))</span>
                <span class="n">H</span> <span class="o">+=</span> <span class="n">Hfull</span><span class="p">[:,</span><span class="n">si</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">:(</span><span class="n">si</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">]</span> <span class="o">*</span> <span class="n">phase</span>
                <span class="n">S</span> <span class="o">+=</span> <span class="n">Sfull</span><span class="p">[:,</span><span class="n">si</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">:(</span><span class="n">si</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">]</span> <span class="o">*</span> <span class="n">phase</span>
            <span class="k">del</span> <span class="n">Hfull</span><span class="p">,</span> <span class="n">Sfull</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">S</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="TightBinding.eigh"><a class="viewcode-back" href="../../../sids.tb.tightbinding.html#sids.tb.tightbinding.TightBinding.eigh">[docs]</a>    <span class="k">def</span> <span class="nf">eigh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">atoms</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">eigvals_only</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">overwrite_a</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">overwrite_b</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the eigenvalues of the tight-binding model</span>

<span class="sd">        Setup the Hamiltonian and overlap matrix with respect to</span>
<span class="sd">        the given k-point, then reduce the space to the specified atoms</span>
<span class="sd">        and calculate the eigenvalues.</span>

<span class="sd">        All subsequent arguments gets passed directly to ``scipy.linalg.eigh``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="c"># Reduce sparsity pattern</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">orbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="c"># Reduce space</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">orbs</span><span class="p">,</span><span class="n">orbs</span><span class="p">]</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">orbs</span><span class="p">,</span><span class="n">orbs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sli</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">todense</span><span class="p">(),</span><span class="n">S</span><span class="o">.</span><span class="n">todense</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">eigvals_only</span><span class="o">=</span><span class="n">eigvals_only</span><span class="p">,</span>
                        <span class="n">overwrite_a</span><span class="o">=</span><span class="n">overwrite_a</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="n">overwrite_b</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    </div>
<div class="viewcode-block" id="TightBinding.cut"><a class="viewcode-back" href="../../../sids.tb.tightbinding.html#sids.tb.tightbinding.TightBinding.cut">[docs]</a>    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">seps</span><span class="p">,</span><span class="n">axis</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Cuts the tight-binding model into different parts.</span>

<span class="sd">        Creates a tight-binding model by retaining the parameters</span>
<span class="sd">        for the cut-out region, possibly creating a super-cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seps  : integer, optional</span>
<span class="sd">           number of times the structure will be cut.</span>
<span class="sd">        axis  : integer</span>
<span class="sd">           the axis that will be cut</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># Create new geometry</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="c"># Cause all warnings to always be triggered.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s">&quot;always&quot;</span><span class="p">)</span>
            <span class="c"># Create new cut geometry</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">seps</span><span class="p">,</span><span class="n">axis</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c"># Check whether the warning exists</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">category</span><span class="p">,</span><span class="ne">UserWarning</span><span class="p">):</span>
                    <span class="n">new_w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">message</span>
                    <span class="n">new_w</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">---</span><span class="se">\n</span><span class="s">&quot;</span>
                              <span class="s">&quot;The tight-binding model cannot be cut as the structure &quot;</span>
                             <span class="s">&quot;cannot be tiled accordingly. ANY use of the model has been &quot;</span>
                             <span class="s">&quot;relieved from sids.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_w</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">new_w</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span> 

        <span class="c"># Now we need to re-create the tight-binding model</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="c"># they are created similarly, hence the following</span>
        <span class="c"># should keep their order</span>

        <span class="c"># First we need to figure out how long the interaction range is</span>
        <span class="c"># in the cut-direction</span>
        <span class="c"># We initialize to be the same as the parent direction</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># we count the new direction</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
            <span class="c"># Get supercell index</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span> 
                <span class="k">break</span>

            <span class="c"># Figure out if the Hamiltonian has interactions</span>
            <span class="c"># to ``isc``</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">,</span><span class="n">idx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">:(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">[:]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">break</span>

            <span class="n">c_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>
            <span class="c"># Count the number of cells it interacts with</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_max</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span> <span class="o">//</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span>
            <span class="n">ic</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">ic</span> <span class="o">+</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">*</span> <span class="n">j</span>
                <span class="c"># We need to ensure that every &quot;in between&quot; index exists</span>
                <span class="c"># if it does not we discard those indices</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> 
                        <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">sub</span><span class="p">,</span> 
                                       <span class="n">sub</span> <span class="o">&lt;</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
                        <span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
            <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">seps</span> <span class="o">+</span> <span class="n">i</span>
            
            <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Cut the connection at nsc={0} in direction {1}.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span><span class="n">axis</span><span class="p">),</span> <span class="ne">UserWarning</span><span class="p">)</span> 

        <span class="c"># Update number of super-cells</span>
        <span class="n">nsc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">nsc</span><span class="p">[:]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c"># Now we have a correct geometry, and </span>
        <span class="c"># we are now ready to create the sparsity pattern</span>
        <span class="c"># Reduce the sparsity pattern, first create the new one</span>
        <span class="n">tb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="n">nc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">sco2sco</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">seps</span><span class="p">,</span><span class="n">axis</span><span class="p">):</span>
            <span class="c"># Converts an o from M to m</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="n">M</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">seps</span>
            <span class="c"># Correct for cell-offset</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">o</span> <span class="o">%</span> <span class="n">M</span><span class="o">.</span><span class="n">no</span><span class="p">)</span> <span class="o">//</span> <span class="n">m</span><span class="o">.</span><span class="n">no</span>
            <span class="c"># find the equivalent cell in m</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># If a fail happens it is due to a discarded</span>
                <span class="c"># interaction across a non-interacting region</span>
                <span class="k">return</span> <span class="p">(</span> <span class="n">o</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> 
                        <span class="n">m</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span> <span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> 
                        <span class="n">m</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

        <span class="c"># Copy elements</span>
        <span class="k">for</span> <span class="n">jo</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">):</span>

            <span class="c"># make smaller cut</span>
            <span class="n">sH</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">jo</span><span class="p">,:]</span>
            <span class="n">sS</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">jo</span><span class="p">,:]</span>

            <span class="k">for</span> <span class="n">io</span><span class="p">,</span> <span class="n">iH</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sH</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span><span class="n">sH</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
                <span class="c"># Get the equivalent orbital in the smaller cell</span>
                <span class="n">o</span><span class="p">,</span> <span class="n">ofp</span><span class="p">,</span> <span class="n">ofm</span> <span class="o">=</span> <span class="n">sco2sco</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="p">,</span><span class="n">io</span><span class="p">,</span><span class="n">tb</span><span class="o">.</span><span class="n">geom</span><span class="p">,</span><span class="n">seps</span><span class="p">,</span><span class="n">axis</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">tb</span><span class="p">[</span><span class="n">jo</span><span class="p">,</span><span class="n">o</span><span class="o">+</span><span class="n">ofp</span><span class="p">]</span> <span class="o">=</span> <span class="n">iH</span><span class="p">,</span> <span class="n">S</span><span class="p">[</span><span class="n">jo</span><span class="p">,</span><span class="n">io</span><span class="p">]</span>
                <span class="n">tb</span><span class="p">[</span><span class="n">o</span><span class="p">,</span><span class="n">jo</span><span class="o">+</span><span class="n">ofm</span><span class="p">]</span> <span class="o">=</span> <span class="n">iH</span><span class="p">,</span> <span class="n">S</span><span class="p">[</span><span class="n">jo</span><span class="p">,</span><span class="n">io</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">tb</span>

</div>
<div class="viewcode-block" id="TightBinding.tile"><a class="viewcode-back" href="../../../sids.tb.tightbinding.html#sids.tb.tightbinding.TightBinding.tile">[docs]</a>    <span class="k">def</span> <span class="nf">tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">reps</span><span class="p">,</span><span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a repeated tight-binding model for this, much like the `Geometry`.</span>

<span class="sd">        The already existing tight-binding parameters are extrapolated </span>
<span class="sd">        to the new supercell by repeating them in blocks like the coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps  : number of tiles (repetitions)</span>
<span class="sd">        axis  : direction of tiling </span>
<span class="sd">                  0, 1, 2 according to the cell-direction</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Create the new geometry</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span><span class="n">axis</span><span class="p">)</span>

        <span class="c"># Get the Hamiltonian and overlap matrices</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="c"># Create new object</span>
        <span class="n">TB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

        <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">((</span><span class="s">&#39;tiling a TightBinding model has not been &#39;</span>
                              <span class="s">&#39;fully implemented yet.&#39;</span><span class="p">))</span>

    </div>
<div class="viewcode-block" id="TightBinding.repeat"><a class="viewcode-back" href="../../../sids.tb.tightbinding.html#sids.tb.tightbinding.TightBinding.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">reps</span><span class="p">,</span><span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Refer to ``self.tile`` instead &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">((</span><span class="s">&#39;repeating a TightBinding model has not been &#39;</span>
                              <span class="s">&#39;fully implemented yet, use tile instead.&#39;</span><span class="p">))</span>

    </div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TightBinding.sp2tb"><a class="viewcode-back" href="../../../sids.tb.tightbinding.html#sids.tb.tightbinding.TightBinding.sp2tb">[docs]</a>    <span class="k">def</span> <span class="nf">sp2tb</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span><span class="n">geom</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">S</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a tight-binding model from a preset H, S and Geometry &quot;&quot;&quot;</span>

        <span class="c"># Calculate number of connections</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">):</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">getnnz</span><span class="p">())</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
        
        <span class="n">tb</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="n">nc</span><span class="o">=</span><span class="n">nc</span><span class="p">)</span>

        <span class="c"># Copy data to the model</span>
        <span class="k">for</span> <span class="n">jo</span><span class="p">,</span><span class="n">io</span><span class="p">,</span><span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">row</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">col</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
            <span class="n">tb</span><span class="p">[</span><span class="n">jo</span><span class="p">,</span><span class="n">io</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">S</span><span class="p">[</span><span class="n">jo</span><span class="p">,</span><span class="n">io</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">tb</span>
</div>
<div class="viewcode-block" id="TightBinding.write"><a class="viewcode-back" href="../../../sids.tb.tightbinding.html#sids.tb.tightbinding.TightBinding.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sile</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Writes a tight-binding model to the ``sile`` as implemented in the ``ObjSile.write_tb``</span>
<span class="sd">        method &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>

        <span class="c"># This only works because, they *must*</span>
        <span class="c"># have been imported previously</span>
        <span class="kn">from</span> <span class="nn">sids.io</span> <span class="kn">import</span> <span class="n">get_sile</span><span class="p">,</span> <span class="n">BaseSile</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span><span class="n">BaseSile</span><span class="p">):</span>
            <span class="n">sile</span><span class="o">.</span><span class="n">write_tb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">get_sile</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">write_tb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        </div></div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">datetime</span>
    <span class="kn">from</span> <span class="nn">sids.geom</span> <span class="kn">import</span> <span class="n">graphene</span>

    <span class="c"># Create graphene unit-cell</span>
    <span class="n">gr</span> <span class="o">=</span> <span class="n">graphene</span><span class="p">()</span>
    <span class="n">gr</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

    <span class="c"># Create nearest-neighbour tight-binding</span>
    <span class="c"># graphene lattice constant 1.42</span>
    <span class="n">dR</span> <span class="o">=</span> <span class="p">(</span> <span class="mf">0.1</span> <span class="p">,</span> <span class="mf">1.5</span> <span class="p">)</span>
    <span class="n">on</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
    
    <span class="n">tb</span> <span class="o">=</span> <span class="n">TightBinding</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">tb</span><span class="o">.</span><span class="n">geom</span><span class="p">:</span>
        <span class="n">idx_a</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="n">dR</span><span class="o">=</span><span class="n">dR</span><span class="p">)</span>
        <span class="n">tb</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span><span class="n">idx_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">on</span>
        <span class="n">tb</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span><span class="n">idx_a</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nn</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span>
    <span class="n">tb</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;H</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span><span class="n">tb</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;H</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span><span class="n">tb</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="p">[</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;eig</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span><span class="n">tb</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="p">[</span><span class="mf">3.</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">eigvals_only</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>


    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Check expansion&#39;</span><span class="p">)</span>
    <span class="n">tb</span> <span class="o">=</span> <span class="n">TightBinding</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span>
    <span class="n">tb</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c"># force only one connection (this should force expansion)</span>
    <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">tb</span><span class="o">.</span><span class="n">geom</span><span class="p">:</span>
        <span class="n">idx_a</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="n">dR</span><span class="o">=</span><span class="n">dR</span><span class="p">)</span>
        <span class="n">tb</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span><span class="n">idx_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">on</span>
        <span class="n">tb</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span><span class="n">idx_a</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nn</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;H</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span><span class="n">tb</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;H</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span><span class="n">tb</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="p">[</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c"># Lets try and create a huge sample</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n\n</span><span class="s">Starting time... &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
    <span class="n">tb</span> <span class="o">=</span> <span class="n">TightBinding</span><span class="p">(</span><span class="n">gr</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">41</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">41</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">tb</span><span class="o">.</span><span class="n">iter_block</span><span class="p">(</span><span class="mi">13</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ias</span><span class="p">:</span>
            <span class="n">idx_a</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="n">dR</span><span class="o">=</span><span class="n">dR</span><span class="p">)</span>
            <span class="n">tb</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span><span class="n">idx_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">on</span>
            <span class="n">tb</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span><span class="n">idx_a</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nn</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tb</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Ending time... &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>

    
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Nick R. Papior.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.4.4
',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>