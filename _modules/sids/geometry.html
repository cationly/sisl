

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sids.geometry</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="None" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> sids
          

          
          </a>

          
            
            
              <div class="version">
                0..
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="simple">
</ul>
<ul class="simple">
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">sids</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>sids.geometry</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sids.geometry</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Geometry class to retain the atomic structure.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="c"># To check for integers</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">acos</span><span class="p">,</span> <span class="n">pi</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>


<span class="kn">from</span> <span class="nn">.quaternion</span> <span class="kn">import</span> <span class="n">Quaternion</span>
<span class="kn">from</span> <span class="nn">.supercell</span> <span class="kn">import</span> <span class="n">SuperCell</span><span class="p">,</span> <span class="n">SuperCellChild</span>
<span class="kn">from</span> <span class="nn">.atom</span> <span class="kn">import</span> <span class="n">Atom</span>
<span class="kn">from</span> <span class="nn">._help</span> <span class="kn">import</span> <span class="n">array_fill_repeat</span><span class="p">,</span> <span class="n">ensure_array</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Geometry&#39;</span><span class="p">]</span>


<span class="c"># Local default variables for the __init__ of the</span>
<span class="c"># Geometry class</span>
<span class="n">_H</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">[</span><span class="s">&#39;H&#39;</span><span class="p">]</span>
<span class="n">_nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>


<div class="viewcode-block" id="Geometry"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry">[docs]</a><span class="k">class</span> <span class="nc">Geometry</span><span class="p">(</span><span class="n">SuperCellChild</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object for retaining a list of atoms.</span>

<span class="sd">    Every geometry deals with this information:</span>
<span class="sd">    - atomic coordinates</span>
<span class="sd">    - atomic species</span>
<span class="sd">    - unit cell </span>
<span class="sd">    </span>
<span class="sd">    All lengths are assumed to be in units of Angstrom, however, as</span>
<span class="sd">    long as units are kept same the exact units are irrespective.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; xyz = [[0, 0, 0],</span>
<span class="sd">               [1, 1, 1]]</span>
<span class="sd">    &gt;&gt;&gt; g = Geometry(xyz,Atom[&#39;H&#39;])</span>

<span class="sd">    &gt;&gt;&gt; sc = SuperCell([2,2,2])</span>
<span class="sd">    &gt;&gt;&gt; g = Geometry(xyz,Atom[&#39;H&#39;],sc)</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    na : int</span>
<span class="sd">        number of atoms, ``len(self)``</span>
<span class="sd">    xyz : ndarray</span>
<span class="sd">        atomic coordinates</span>
<span class="sd">    atoms : array_like, ``Atom``</span>
<span class="sd">        the atomic objects associated with each atom</span>
<span class="sd">    sc : ``SuperCell``</span>
<span class="sd">        the supercell describing the periodicity of the </span>
<span class="sd">        geometry</span>
<span class="sd">    no: int</span>
<span class="sd">        total number of orbitals in the geometry</span>
<span class="sd">    dR : float np.max([a.dR for a in self.atoms])</span>
<span class="sd">        maximum orbital range</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xyz : array_like</span>
<span class="sd">        atomic coordinates</span>
<span class="sd">        ``xyz[i,:]`` is the atomic coordinate of the i&#39;th atom.</span>
<span class="sd">    atoms : array_like</span>
<span class="sd">        atomic species retrieved from the ``PeriodicTable``</span>
<span class="sd">    sc : ``SuperCell``</span>
<span class="sd">        the unit-cell describing the atoms in a periodic</span>
<span class="sd">        super-cell</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">xyz</span><span class="p">,</span><span class="n">atoms</span><span class="o">=</span><span class="n">_H</span><span class="p">,</span><span class="n">sc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="c"># Create the geometry coordinate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>

        <span class="c"># Correct the atoms input to Atom</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">str</span><span class="p">):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Atom</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Atom</span><span class="p">(</span><span class="n">atoms</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atoms</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c"># Create atom objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="n">array_fill_repeat</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Atom</span><span class="p">)</span>

        <span class="c"># Store maximum interaction range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">dR</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">])</span>

        <span class="c"># Get total number of orbitals</span>
        <span class="n">orbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">orbs</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c"># Get total number of orbitals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>

        <span class="c"># Create local lasto</span>
        <span class="n">lasto</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">orbs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lasto</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__init_sc</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>

        
    <span class="k">def</span> <span class="nf">__init_sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initializes the supercell by *calculating* the size if not supplied</span>

<span class="sd">        If the supercell has not been passed we estimate the unit cell size</span>
<span class="sd">        by calculating the bond-length in each direction for a square</span>
<span class="sd">        Cartesian coordinate system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># We still need the *default* super cell for</span>
        <span class="c"># estimating the supercell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_supercell</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c"># First create an initial guess for the supercell</span>
        <span class="c"># It HAS to be VERY large to not interact</span>
        <span class="n">closest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dR</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">5.</span><span class="p">))[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># We could not find any atoms very close,</span>
            <span class="c"># hence we simply return and now it becomes</span>
            <span class="c"># the users responsibility</span>
            <span class="k">return</span>

        <span class="n">sc_cart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">cart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="c"># Initialize cartesian direction</span>
            <span class="n">cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            
            <span class="c"># Get longest distance between atoms</span>
            <span class="n">max_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
            
            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">closest</span><span class="p">,:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">,:][</span><span class="bp">None</span><span class="p">,:]</span>
            <span class="c"># Project onto the direction</span>
            <span class="n">dd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">cart</span><span class="p">))</span>

            <span class="c"># Remove all below .4</span>
            <span class="n">tmp_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dd</span> <span class="o">&gt;=</span> <span class="o">.</span><span class="mi">4</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># We have a success</span>
                <span class="c"># Add the bond-distance in the Cartesian direction</span>
                <span class="c"># to the maximum distance in the same direction</span>
                <span class="n">sc_cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_dist</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">dd</span><span class="p">[</span><span class="n">tmp_idx</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Default to LARGE array so as no</span>
                <span class="c"># interaction occurs (it may be 2D)</span>
                <span class="n">sc_cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span><span class="n">max_dist</span><span class="p">)</span>
            <span class="n">cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            
        <span class="c"># Re-set the supercell to the newly found one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_supercell</span><span class="p">(</span><span class="n">sc_cart</span><span class="p">)</span>

        
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return number of atoms in this geometry &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>


    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns geometry coordinates &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xa</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>


    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Geometry.read"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">sile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reads geometry from the ``Sile`` using ``sile.read_geom``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sile : Sile, str</span>
<span class="sd">            a ``Sile`` object which will be used to read the geometry</span>
<span class="sd">            if it is a string it will create a new sile using ``get_sile``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># This only works because, they *must*</span>
        <span class="c"># have been imported previously</span>
        <span class="kn">from</span> <span class="nn">sids.io</span> <span class="kn">import</span> <span class="n">get_sile</span><span class="p">,</span> <span class="n">BaseSile</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span><span class="n">BaseSile</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">sile</span><span class="o">.</span><span class="n">read_geom</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">get_sile</span><span class="p">(</span><span class="n">sile</span><span class="p">)</span><span class="o">.</span><span class="n">read_geom</span><span class="p">()</span>
           
</div>
<div class="viewcode-block" id="Geometry.write"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sile</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Writes geometry to the ``Sile`` using ``sile.write_geom``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sile : Sile, str</span>
<span class="sd">            a ``Sile`` object which will be used to write the geometry</span>
<span class="sd">            if it is a string it will create a new sile using ``get_sile``</span>
<span class="sd">        *args, **kwargs: Any other args will be passed directly to the</span>
<span class="sd">                         underlying routine</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># This only works because, they *must*</span>
        <span class="c"># have been imported previously</span>
        <span class="kn">from</span> <span class="nn">sids.io</span> <span class="kn">import</span> <span class="n">get_sile</span><span class="p">,</span> <span class="n">BaseSile</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span><span class="n">BaseSile</span><span class="p">):</span>
            <span class="n">sile</span><span class="o">.</span><span class="n">write_geom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">get_sile</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">write_geom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Representation of the object &quot;&quot;&quot;</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_species_order</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;{{na: {0}, no: {1}, species:</span><span class="se">\n</span><span class="s"> {{ n: {2},</span><span class="se">\n</span><span class="s">   &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">spec</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;[{0}], &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s"> }},</span><span class="se">\n</span><span class="s"> nsc: [{1}, {2}, {3}], dR: {0}</span><span class="se">\n</span><span class="s">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dR</span><span class="p">,</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="p">)</span>

    
<div class="viewcode-block" id="Geometry.iter_species"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.iter_species">[docs]</a>    <span class="k">def</span> <span class="nf">iter_species</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Returns an iterator over all atoms and species as a tuple in this geometry</span>
<span class="sd">        </span>
<span class="sd">         &gt;&gt;&gt; for ia,a,idx_specie in self.iter_species():</span>

<span class="sd">        with ``ia`` being the atomic index, ``a`` the ``Atom`` object, ``idx_specie``</span>
<span class="sd">        is the index of the species</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Count for the species</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ia</span><span class="p">,</span><span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">tag</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">:</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># It must already exist in the species list</span>
                <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">spec</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Geometry.iter_linear"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.iter_linear">[docs]</a>    <span class="k">def</span> <span class="nf">iter_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator for simple linear ranges.</span>

<span class="sd">        This iterator is the same as:</span>

<span class="sd">          &gt;&gt;&gt; for ia in range(len(self)):</span>
<span class="sd">          &gt;&gt;&gt;    &lt;do something&gt;</span>
<span class="sd">        or equivalently</span>
<span class="sd">          &gt;&gt;&gt; for ia in self:</span>
<span class="sd">          &gt;&gt;&gt;    &lt;do something&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">ia</span>
</div>
    <span class="n">__iter__</span> <span class="o">=</span> <span class="n">iter_linear</span>


<div class="viewcode-block" id="Geometry.iter_block"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.iter_block">[docs]</a>    <span class="k">def</span> <span class="nf">iter_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">iR</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">dR</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Returns an iterator for performance critical looping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iR  : (10) integer</span>
<span class="sd">            the number of ``dR`` ranges taken into account when doing the iterator</span>
<span class="sd">        dR  : (self.dR), float</span>
<span class="sd">            enables overwriting the local dR quantity.</span>
<span class="sd"> </span>
<span class="sd">        Returns two lists with [0] being a list of atoms to be looped and [1] being the atoms that </span>
<span class="sd">        need searched.</span>

<span class="sd">        NOTE: This requires that dR has been set correctly as the maximum interaction range.</span>

<span class="sd">        I.e. the loop would look like this:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; for ias, idxs in Geometry.iter_block():</span>
<span class="sd">        &gt;&gt;&gt;    for ia in ias:</span>
<span class="sd">        &gt;&gt;&gt;        idx_a = dev.close(ia, dR = dR, idx = idxs)</span>

<span class="sd">        This iterator is intended for systems with more than 1000 atoms.</span>

<span class="sd">        Remark that the iterator used is non-deterministic, i.e. any two iterators need</span>
<span class="sd">        not return the same atoms in any way.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># We implement yields as we can then do nested iterators</span>
        <span class="c"># create a boolean array</span>
        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">not_passed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">na</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">not_passed</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">not_passed_N</span> <span class="o">=</span> <span class="n">na</span>

        <span class="k">if</span> <span class="n">dR</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># The boundaries (ensure complete overlap)</span>
            <span class="n">dr</span> <span class="o">=</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">dR</span> <span class="o">*</span> <span class="p">(</span><span class="n">iR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dR</span> <span class="o">*</span> <span class="p">(</span><span class="n">iR</span><span class="o">+.</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dr</span> <span class="o">=</span> <span class="p">(</span>      <span class="n">dR</span> <span class="o">*</span> <span class="p">(</span><span class="n">iR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>      <span class="n">dR</span> <span class="o">*</span> <span class="p">(</span><span class="n">iR</span><span class="o">+.</span><span class="mi">1</span><span class="p">))</span>


        <span class="c"># loop until all passed are true</span>
        <span class="k">while</span> <span class="n">not_passed_N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="c"># Take a random non-passed element</span>
            <span class="n">all_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">not_passed</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c"># Shuffle should increase the chance of hitting a</span>
            <span class="c"># completely &quot;fresh&quot; segment, thus we take the most </span>
            <span class="c"># atoms at any single time.</span>
            <span class="c"># Shuffling will cut down needed iterations.</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">all_true</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">all_true</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">all_true</span>

            <span class="c"># Now we have found a new index, from which</span>
            <span class="c"># we want to create the index based stuff on</span>
            
            <span class="c"># get all elements within two radii</span>
            <span class="n">all_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dR</span> <span class="o">=</span> <span class="n">dr</span> <span class="p">)</span>

            <span class="c"># Get unit-cell atoms</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uniq</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c"># First extend the search-space (before reducing)</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">uniq</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c"># Only select those who have not been runned yet</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]])[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Internal error, please report to the developers&#39;</span><span class="p">)</span>

            <span class="c"># Tell the next loop to skip those passed</span>
            <span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="c"># Update looped variables</span>
            <span class="n">not_passed_N</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c"># Now we want to yield the stuff revealed</span>
            <span class="c"># all_idx[0] contains the elements that should be looped</span>
            <span class="c"># all_idx[1] contains the indices that can be searched</span>
            <span class="k">yield</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">not_passed</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Error on iterations. Not all atoms has been visited.&#39;</span><span class="p">)</span>
    
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">no_s</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of supercell orbitals &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span>


<div class="viewcode-block" id="Geometry.sub"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.sub">[docs]</a>    <span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atoms</span><span class="p">,</span><span class="n">cell</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a subset of atoms from the geometry.</span>

<span class="sd">        Indices passed *MUST* be unique.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms  : array_like</span>
<span class="sd">            indices of all atoms to be removed.</span>
<span class="sd">        cell   : (``self.cell`), array_like, optional</span>
<span class="sd">            the new associated cell of the geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">atoms</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cell</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> 
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">,:],</span>
                                  <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">atms</span><span class="p">],</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">,:],</span>
                            <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">atms</span><span class="p">],</span> <span class="n">sc</span><span class="o">=</span><span class="n">cell</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Geometry.cut"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.cut">[docs]</a>    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">seps</span><span class="p">,</span><span class="n">axis</span><span class="p">,</span><span class="n">seg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">rtol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a subset of atoms from the geometry by cutting the </span>
<span class="sd">        geometry into ``seps`` parts along the direction ``axis``.</span>
<span class="sd">        It will then _only_ return the first cut.</span>
<span class="sd">        </span>
<span class="sd">        This will effectively change the unit-cell in the ``axis`` as-well</span>
<span class="sd">        as removing ``self.na_u/seps`` atoms.</span>
<span class="sd">        It requires that ``self.na_u % seps == 0``.</span>

<span class="sd">        REMARK: You need to ensure that all atoms within the first </span>
<span class="sd">        cut out region are within the primary unit-cell.</span>

<span class="sd">        Doing ``geom.cut(2,1).tile(reps=2,axis=1)``, could for symmetric setups,</span>
<span class="sd">        be equivalent to a no-op operation. A `UserWarning` will be issued</span>
<span class="sd">        if this is not the case.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis  : int</span>
<span class="sd">            the axis that will be cut</span>
<span class="sd">        seps  : int</span>
<span class="sd">            number of times the structure will be cut.</span>
<span class="sd">        seg : int, optional (0)</span>
<span class="sd">            returns the i&#39;th segment of the cut structure</span>
<span class="sd">            Currently the atomic coordinates are not translated,</span>
<span class="sd">            this may change in the future.</span>
<span class="sd">        rtol : (tolerance for checking tiling, see ``numpy.allclose``)</span>
<span class="sd">        atol : (tolerance for checking tiling, see ``numpy.allclose``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">%</span> <span class="n">seps</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;The system cannot be cut into {0} different &#39;</span><span class="o">+</span>
                             <span class="s">&#39;pieces. Please check your geometry and input.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seps</span><span class="p">))</span>
        <span class="c"># Truncate to the correct segments</span>
        <span class="n">lseg</span> <span class="o">=</span> <span class="n">seg</span> <span class="o">%</span> <span class="n">seps</span>
        <span class="c"># Cut down cell</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">seps</span><span class="p">,</span><span class="n">axis</span><span class="p">)</span>
        <span class="c"># List of atoms</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">//</span> <span class="n">seps</span>
        <span class="n">off</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">lseg</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">off</span><span class="p">,</span><span class="n">off</span><span class="o">+</span><span class="n">n</span><span class="p">),</span> <span class="n">cell</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="s">&#39;The cut structure cannot be re-created by tiling&#39;</span>
            <span class="n">st</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">The difference between the coordinates can be altered using rtol, atol&#39;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">new</span>

</div>
    <span class="k">def</span> <span class="nf">_species_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns dictionary with species indices for the atoms.</span>
<span class="sd">        They will be populated in order of appearence&quot;&quot;&quot;</span>

        <span class="c"># Count for the species</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ispec</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">tag</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">tag</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">:</span>
                    <span class="n">ispec</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">spec</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ispec</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">Z</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">:</span>
                <span class="n">ispec</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">spec</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">Z</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ispec</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spec</span>


<div class="viewcode-block" id="Geometry.copy"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">),</span>
                              <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

</div>
<div class="viewcode-block" id="Geometry.remove"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove atoms from the geometry.</span>

<span class="sd">        Indices passed *MUST* be unique.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms  : array_like</span>
<span class="sd">            indices of all atoms to be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">),</span><span class="n">atoms</span><span class="p">,</span><span class="n">assume_unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Geometry.tile"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.tile">[docs]</a>    <span class="k">def</span> <span class="nf">tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">reps</span><span class="p">,</span><span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Returns a geometry tiled, i.e. copied.</span>

<span class="sd">        The atomic indices are retained for the base structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps  : number of tiles (repetitions)</span>
<span class="sd">        axis  : direction of tiling </span>
<span class="sd">                  0, 1, 2 according to the cell-direction</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = Geometry(cell=[[1.,0,0],[0,1.,0.],[0,0,1.]],xyz=[[0,0,0],[0.5,0,0]])</span>
<span class="sd">        &gt;&gt;&gt; g = geom.tile(2,axis=0)</span>
<span class="sd">        &gt;&gt;&gt; print(g.xyz)</span>
<span class="sd">        [[ 0.   0.   0. ]</span>
<span class="sd">         [ 0.5  0.   0. ]</span>
<span class="sd">         [ 1.   0.   0. ]</span>
<span class="sd">         [ 1.5  0.   0. ]]</span>
<span class="sd">        &gt;&gt;&gt; g = geom.tile(2,0).tile(2,axis=1)</span>
<span class="sd">        &gt;&gt;&gt; print(g.xyz)</span>
<span class="sd">        [[ 0.   0.   0. ]</span>
<span class="sd">         [ 0.5  0.   0. ]</span>
<span class="sd">         [ 1.   0.   0. ]</span>
<span class="sd">         [ 1.5  0.   0. ]</span>
<span class="sd">         [ 0.   1.   0. ]</span>
<span class="sd">         [ 0.5  1.   0. ]</span>
<span class="sd">         [ 1.   1.   0. ]</span>
<span class="sd">         [ 1.5  1.   0. ]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># We need a double copy as we want to re-calculate after</span>
        <span class="c"># enlarging cell</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span> <span class="o">*=</span> <span class="n">reps</span>
        <span class="c"># Only reduce the size if it is larger than 5</span>
        <span class="k">if</span> <span class="n">sc</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">reps</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c"># Pre-allocate geometry</span>
        <span class="c"># Our first repetition *must* be with</span>
        <span class="c"># the later coordinate</span>
        <span class="c"># Copy the entire structure</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,(</span><span class="n">reps</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="c"># Single cell displacements</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">reps</span><span class="p">)[:,</span><span class="bp">None</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:][</span><span class="bp">None</span><span class="p">,:])</span>
        <span class="c"># Correct the unit-cell offsets</span>
        <span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="o">*</span><span class="n">reps</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c"># Create the geometry and return it (note the smaller atoms array</span>
        <span class="c"># will also expand via tiling)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Geometry.repeat"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">reps</span><span class="p">,</span><span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a geometry repeated, i.e. copied in a special way.</span>

<span class="sd">        The atomic indices are *NOT* retained for the base structure.</span>

<span class="sd">        The expansion of the atoms are basically performed using this</span>
<span class="sd">        algorithm:</span>
<span class="sd">          ja = 0</span>
<span class="sd">          for ia in range(self.na):</span>
<span class="sd">              for id,r in args:</span>
<span class="sd">                 for i in range(r):</span>
<span class="sd">                    ja = ia + cell[id,:] * i</span>

<span class="sd">        This method allows to utilise Bloch&#39;s theorem when creating</span>
<span class="sd">        tight-binding parameter sets for TBtrans.</span>

<span class="sd">        For geometries with a single atom this routine returns the same as</span>
<span class="sd">        ``self.tile``.</span>

<span class="sd">        It is adviced to only use this for electrode Bloch&#39;s theorem</span>
<span class="sd">        purposes as ``self.tile`` is faster.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps  : number of repetitions</span>
<span class="sd">        axis  : direction of repetition</span>
<span class="sd">                  0, 1, 2 according to the cell-direction</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = Geometry(cell=[[1.,0,0],[0,1.,0.],[0,0,1.]],xyz=[[0,0,0],[0.5,0,0]])</span>
<span class="sd">        &gt;&gt;&gt; g = geom.repeat(2,axis=0)</span>
<span class="sd">        &gt;&gt;&gt; print(g.xyz)</span>
<span class="sd">        [[ 0.   0.   0. ]</span>
<span class="sd">         [ 1.   0.   0. ]</span>
<span class="sd">         [ 0.5  0.   0. ]</span>
<span class="sd">         [ 1.5  0.   0. ]]</span>
<span class="sd">        &gt;&gt;&gt; g = geom.repeat(2,0).repeat(2,1)</span>
<span class="sd">        &gt;&gt;&gt; print(g.xyz)</span>
<span class="sd">        [[ 0.   0.   0. ]</span>
<span class="sd">         [ 1.   0.   0. ]</span>
<span class="sd">         [ 0.   1.   0. ]</span>
<span class="sd">         [ 1.   1.   0. ]</span>
<span class="sd">         [ 0.5  0.   0. ]</span>
<span class="sd">         [ 1.5  0.   0. ]</span>
<span class="sd">         [ 0.5  1.   0. ]</span>
<span class="sd">         [ 1.5  1.   0. ]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Figure out the size</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span> <span class="o">*=</span> <span class="n">reps</span>
        <span class="c"># Only reduce the size if it is larger than 5</span>
        <span class="k">if</span> <span class="n">sc</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">reps</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c"># Pre-allocate geometry</span>
        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="n">reps</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">na</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">)]</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">reps</span><span class="p">)[:,</span><span class="bp">None</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:][</span><span class="bp">None</span><span class="p">,:])</span>
        <span class="c"># Start the repetition</span>
        <span class="n">ja</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">):</span>
            <span class="c"># Single atom displacements</span>
            <span class="c"># First add the basic atomic coordinate,</span>
            <span class="c"># then add displacement for each repetition.</span>
            <span class="n">xyz</span><span class="p">[</span><span class="n">ja</span><span class="p">:</span><span class="n">ja</span><span class="o">+</span><span class="n">reps</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ia</span><span class="p">,:][</span><span class="bp">None</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[:,:]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
                <span class="n">atoms</span><span class="p">[</span><span class="n">ja</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span>
            <span class="n">ja</span> <span class="o">+=</span> <span class="n">reps</span>
        <span class="c"># Create the geometry and return it</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Geometry.rotatea"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.rotatea">[docs]</a>    <span class="k">def</span> <span class="nf">rotatea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">only</span><span class="o">=</span><span class="s">&#39;abc+xyz&#39;</span><span class="p">,</span><span class="n">degree</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span><span class="n">only</span><span class="o">=</span><span class="n">only</span><span class="p">,</span><span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span></div>
<div class="viewcode-block" id="Geometry.rotateb"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.rotateb">[docs]</a>    <span class="k">def</span> <span class="nf">rotateb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">only</span><span class="o">=</span><span class="s">&#39;abc+xyz&#39;</span><span class="p">,</span><span class="n">degree</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span><span class="n">only</span><span class="o">=</span><span class="n">only</span><span class="p">,</span><span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span></div>
<div class="viewcode-block" id="Geometry.rotatec"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.rotatec">[docs]</a>    <span class="k">def</span> <span class="nf">rotatec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">only</span><span class="o">=</span><span class="s">&#39;abc+xyz&#39;</span><span class="p">,</span><span class="n">degree</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">,:],</span><span class="n">only</span><span class="o">=</span><span class="n">only</span><span class="p">,</span><span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Geometry.rotate"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">only</span><span class="o">=</span><span class="s">&#39;abc+xyz&#39;</span><span class="p">,</span><span class="n">degree</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Rotates the geometry, in-place by the angle around the vector</span>

<span class="sd">        Per default will the entire geometry be rotated, such that everything</span>
<span class="sd">        is aligned as before rotation.</span>

<span class="sd">        However, by supplying ``only=&#39;abc|xyz&#39;`` one can designate which</span>
<span class="sd">        part of the geometry that will be rotated.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle : float</span>
<span class="sd">             the angle in radians of which the geometry should be rotated</span>
<span class="sd">        v     : array_like [3]</span>
<span class="sd">             the vector around the rotation is going to happen</span>
<span class="sd">             v = [1,0,0] will rotate in the ``yz`` plane</span>
<span class="sd">        only  : (&#39;abc+xyz&#39;), str, optional</span>
<span class="sd">             which coordinate subject should be rotated,</span>
<span class="sd">             if ``abc`` is in this string the cell will be rotated</span>
<span class="sd">             if ``xyz`` is in this string the coordinates will be rotated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)[:]</span>
        <span class="n">vn</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vn</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">vn</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">/=</span> <span class="n">q</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="c"># normalize the quaternion</span>

        <span class="c"># Rotate by direct call</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">vn</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="n">only</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="s">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">only</span><span class="p">:</span> 
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Geometry.rotate_miller"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.rotate_miller">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_miller</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Align Miller direction along ``v`` </span>

<span class="sd">        Rotate geometry and cell such that the Miller direction </span>
<span class="sd">        points along the Cartesian vector ``v``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Create normal vector to miller direction and cartesian</span>
        <span class="c"># direction</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                       <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                       <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">cp</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cp</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>

        <span class="n">lm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">lm</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lm</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>
        <span class="n">lv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">lv</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lv</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>

        <span class="c"># Now rotate the angle between them</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">acos</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lm</span><span class="o">*</span><span class="n">lv</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">cp</span><span class="p">)</span>
        
</div>
<div class="viewcode-block" id="Geometry.translate"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">atoms</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">cell</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Translates the geometry by ``v``</span>

<span class="sd">        One can translate a subset of the atoms by supplying ``atoms``.</span>

<span class="sd">        Returns a copy of the structure translated by ``v``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="bp">None</span><span class="p">,:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="bp">None</span><span class="p">,:]</span>
        <span class="k">if</span> <span class="n">cell</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">set_supercell</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">g</span>

</div>
<div class="viewcode-block" id="Geometry.swapaxes"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.swapaxes">[docs]</a>    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">swap</span><span class="o">=</span><span class="s">&#39;cell+xyz&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns geometry with swapped axis</span>
<span class="sd">        </span>
<span class="sd">        If ``swapaxes(0,1)`` it returns the 0 and 1 values</span>
<span class="sd">        swapped in the ``cell`` variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">swap</span><span class="p">:</span>
            <span class="n">xyz</span><span class="p">[:,</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span><span class="n">b</span><span class="p">]</span>
            <span class="n">xyz</span><span class="p">[:,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span><span class="n">a</span><span class="p">]</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;cell&#39;</span> <span class="ow">in</span> <span class="n">swap</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

    </div>
<div class="viewcode-block" id="Geometry.center"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.center">[docs]</a>    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atoms</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">which</span><span class="o">=</span><span class="s">&#39;xyz&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the center of the geometry </span>
<span class="sd">        By specifying ``which`` one can control whether it should be:</span>
<span class="sd">        ``xyz``|``position: Center of coordinates (default)</span>
<span class="sd">        ``mass``: Center of mass</span>
<span class="sd">        ``cell``: Center of cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s">&#39;cell&#39;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;mass&#39;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">:</span>
            <span class="c"># Create list of masses</span>
            <span class="n">mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atm</span><span class="o">.</span><span class="n">mass</span> <span class="k">for</span> <span class="n">atm</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mass</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="s">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">which</span> <span class="ow">or</span> <span class="s">&#39;position&#39;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Unknown ``which``, not one of [xyz,position,mass,cell]&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Geometry.append"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends structure along ``axis``. This will automatically</span>
<span class="sd">        add the ``self.cell[axis,:]`` to all atomic coordiates in the </span>
<span class="sd">        ``other`` structure before appending.</span>

<span class="sd">        The basic algorithm is this:</span>
<span class="sd">        </span>
<span class="sd">          &gt;&gt;&gt; oxa = other.xyz + self.cell[axis,:][None,:]</span>
<span class="sd">          &gt;&gt;&gt; self.xyz = np.append(self.xyz,oxa)</span>
<span class="sd">          &gt;&gt;&gt; self.cell[axis,:] += other.cell[axis,:]</span>
<span class="sd">          &gt;&gt;&gt; self.lasto = np.append(self.lasto,other.lasto)</span>

<span class="sd">        NOTE: The cell appended is only in the axis that</span>
<span class="sd">        is appended, which means that the other cell directions</span>
<span class="sd">        need not conform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geometry/SuperCell</span>
<span class="sd">            Other geometry class which needs to be appended</span>
<span class="sd">            If a SuperCell only the super cell will be extended</span>
<span class="sd">        axis  : int</span>
<span class="sd">            Cell direction to which the ``other`` geometry should be</span>
<span class="sd">            appended.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">SuperCell</span><span class="p">):</span>
            <span class="c"># Only</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:][</span><span class="bp">None</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Geometry.reverse"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.reverse">[docs]</a>    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atoms</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a reversed geometry</span>

<span class="sd">        Also enables reversing a subset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
            <span class="n">atms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],:]</span>
            <span class="n">atms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">atms</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">=</span> <span class="n">atms</span><span class="p">[</span><span class="n">atoms</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    </div>
<div class="viewcode-block" id="Geometry.mirror"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">plane</span><span class="p">,</span><span class="n">atoms</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Mirrors the structure around the center of the atoms &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">lplane</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">lower</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">lplane</span> <span class="o">==</span> <span class="s">&#39;xy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">lplane</span> <span class="o">==</span> <span class="s">&#39;yz&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">lplane</span> <span class="o">==</span> <span class="s">&#39;xz&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        
    </div>
<div class="viewcode-block" id="Geometry.insert"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atom</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Inserts other atoms right before index</span>

<span class="sd">        We insert the `other` ``Geometry`` before obj</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span><span class="n">atom</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

</div>
<div class="viewcode-block" id="Geometry.coords"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">isc</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">idx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinates of a given super-cell index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        isc   : array_like</span>
<span class="sd">            Returns the atomic coordinates shifted according to the integer</span>
<span class="sd">            parts of the cell.</span>
<span class="sd">        idx   : int/array_like</span>
<span class="sd">            Only return the coordinates of these indices</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; geom = Geometry(cell=[[1.,0,0],[0,1.,0.],[0,0,1.]],xyz=[[0,0,0],[0.5,0,0]])</span>
<span class="sd">        &gt;&gt;&gt; print(geom.coords(isc=[1,0,0])</span>
<span class="sd">        [[ 1.   0.   0. ]</span>
<span class="sd">         [ 1.5  0.   0. ]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="bp">None</span><span class="p">,:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">idx</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="bp">None</span><span class="p">,:]</span>

</div>
<div class="viewcode-block" id="Geometry.axyzsc"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.axyzsc">[docs]</a>    <span class="k">def</span> <span class="nf">axyzsc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ia</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">ia</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="Geometry.close_sc"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.close_sc">[docs]</a>    <span class="k">def</span> <span class="nf">close_sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">xyz_ia</span><span class="p">,</span><span class="n">isc</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">dR</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">idx</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">ret_coord</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">ret_dist</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates which atoms are close to some atom or point</span>
<span class="sd">        in space, only returns so relative to a super-cell.</span>

<span class="sd">        This returns a set of atomic indices which are within a </span>
<span class="sd">        sphere of radius ``dR``.</span>

<span class="sd">        If dR is a tuple/list/array it will return the indices:</span>
<span class="sd">        in the ranges:</span>
<span class="sd">           ( x &lt;= dR[0] , dR[0] &lt; x &lt;= dR[1], dR[1] &lt; x &lt;= dR[2] )</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz_ia    : coordinate/index</span>
<span class="sd">            Either a point in space or an index of an atom.</span>
<span class="sd">            If an index is passed it is the equivalent of passing</span>
<span class="sd">            the atomic coordinate ``self.close_sc(self.xyz[xyz_ia,:])``.</span>
<span class="sd">        isc       : ([0,0,0]), array_like, optional</span>
<span class="sd">            The super-cell which the coordinates are checked in.</span>
<span class="sd">        dR        : (None), float/tuple of float</span>
<span class="sd">            The radii parameter to where the atomic connections are found.</span>
<span class="sd">            If ``dR`` is an array it will return the indices:</span>
<span class="sd">            in the ranges:</span>
<span class="sd">               ``( x &lt;= dR[0] , dR[0] &lt; x &lt;= dR[1], dR[1] &lt; x &lt;= dR[2] )``</span>
<span class="sd">            If a single float it will return:</span>
<span class="sd">               ``x &lt;= dR``</span>
<span class="sd">        idx       : (None), array_like</span>
<span class="sd">            List of atoms that will be considered. This can</span>
<span class="sd">            be used to only take out a certain atoms.</span>
<span class="sd">        ret_coord : (False), boolean</span>
<span class="sd">            If true this method will return the coordinates </span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_dist : (False), boolean</span>
<span class="sd">            If true this method will return the distance</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dR</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ddR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dR</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ddR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dR</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c"># Convert to actual array</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">,</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">xyz_ia</span><span class="p">,:]</span>
            <span class="c"># Get atomic coordinate in principal cell</span>
            <span class="n">dxa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span><span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span> <span class="o">-</span> <span class="n">off</span><span class="p">[</span><span class="bp">None</span><span class="p">,:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">off</span> <span class="o">=</span> <span class="n">xyz_ia</span>
            <span class="c"># The user has passed a coordinate</span>
            <span class="n">dxa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span><span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span> <span class="o">-</span> <span class="n">off</span><span class="p">[</span><span class="bp">None</span><span class="p">,:]</span>

        <span class="n">ret_special</span> <span class="o">=</span> <span class="n">ret_coord</span> <span class="ow">or</span> <span class="n">ret_dist</span>

        <span class="c"># Retrieve all atomic indices which are closer</span>
        <span class="c"># than our delta-R</span>
        <span class="c"># The linear algebra norm function could be used, but it</span>
        <span class="c"># has a lot of checks, hence we do it manually</span>
        <span class="c">#xaR = np.linalg.norm(dxa,axis=-1)</span>
        <span class="n">xaR</span> <span class="o">=</span> <span class="p">(</span><span class="n">dxa</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">dxa</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">dxa</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="o">.</span><span class="mi">5</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">xaR</span> <span class="o">&lt;=</span> <span class="n">ddR</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">ret_coord</span><span class="p">:</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">dxa</span><span class="p">[</span><span class="n">ix</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">off</span><span class="p">[</span><span class="bp">None</span><span class="p">,:]</span>
        <span class="k">if</span> <span class="n">ret_dist</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">xaR</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">dxa</span> <span class="c"># just because these arrays could be very big...</span>

        <span class="c"># Check whether we only have one range to check.</span>
        <span class="c"># If so, we need not reduce the index space</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ddR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">ix</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">ix</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">ret_coord</span><span class="p">:</span> <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret_dist</span><span class="p">:</span> <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">,)</span>
            <span class="k">if</span> <span class="n">ret_special</span><span class="p">:</span> <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ddR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Proximity checks for several quantities &#39;</span><span class="o">+</span> \
                                 <span class="s">&#39;at a time requires ascending dR values.&#39;</span><span class="p">)</span>

        <span class="c"># Reduce search space!</span>
        <span class="c"># The more neigbours you wish to find the faster this becomes</span>
        <span class="c"># We only do &quot;one&quot; heavy duty search,</span>
        <span class="c"># then we immediately reduce search space to this subspace</span>
        <span class="n">xaR</span> <span class="o">=</span> <span class="n">xaR</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
        <span class="n">tidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">xaR</span> <span class="o">&lt;=</span> <span class="n">ddR</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span> <span class="p">]</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="n">tidx</span><span class="p">]])</span> <span class="p">]</span> <span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ret_coord</span><span class="p">:</span> 
            <span class="n">rc</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xa</span><span class="p">[</span><span class="n">tidx</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">ret_dist</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">tidx</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ddR</span><span class="p">)):</span>
            <span class="c"># Search in the sub-space</span>
            <span class="c"># Notice that this sub-space reduction will never</span>
            <span class="c"># allow the same indice to be in two ranges (due to</span>
            <span class="c"># numerics)</span>
            <span class="n">tidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ddR</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">xaR</span><span class="p">,</span><span class="n">xaR</span> <span class="o">&lt;=</span> <span class="n">ddR</span><span class="p">[</span><span class="n">i</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">ensure_array</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="n">tidx</span><span class="p">]])</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">ret_coord</span><span class="p">:</span> <span class="n">ret</span><span class="p">[</span><span class="n">rc</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xa</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ret_dist</span><span class="p">:</span> <span class="n">ret</span><span class="p">[</span><span class="n">rd</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">ret_special</span><span class="p">:</span> <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="Geometry.bond_correct"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.bond_correct">[docs]</a>    <span class="k">def</span> <span class="nf">bond_correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ia</span><span class="p">,</span><span class="n">atoms</span><span class="p">,</span><span class="n">radii</span><span class="o">=</span><span class="s">&#39;calc&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Corrects the bond between `ia` and the `atoms`. </span>

<span class="sd">        Corrects the bond-length between atom `ia` and `atoms` in such</span>
<span class="sd">        a way that the atomic radii is preserved.</span>
<span class="sd">        I.e. the sum of the bond-lengths minimizes the distance matrix.</span>

<span class="sd">        Only atom `ia` is moved.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ia : int</span>
<span class="sd">            The atom to be displaced according to the atomic radii</span>
<span class="sd">        atoms : int, array_like</span>
<span class="sd">            The atom(s) from which the radii should be reduced.</span>
<span class="sd">        radii : str/float</span>
<span class="sd">            If str will use that as lookup in `Atom.radii`.</span>
<span class="sd">            Else it will be the new bond-length.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Decide which algorithm to choose from</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c"># a single point</span>
            <span class="n">algo</span> <span class="o">=</span> <span class="n">atoms</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">algo</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># signal a list of atoms</span>
            <span class="n">algo</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            
        <span class="k">if</span> <span class="n">algo</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c"># We have a single atom</span>
            <span class="c"># Get bond length in the closest direction</span>
            <span class="c"># A bond-length HAS to be below 10 </span>
            <span class="n">idx</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="n">dR</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">10.</span><span class="p">),</span><span class="n">idx</span><span class="o">=</span><span class="n">algo</span><span class="p">,</span>
                                   <span class="n">ret_coord</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">ret_dist</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c"># Convert to unitcell atoms</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

            <span class="c"># Calculate the bond vector</span>
            <span class="n">bv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ia</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">c</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c"># If it is a number, we use that.</span>
                <span class="n">rad</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">radii</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c"># get radii</span>
                <span class="n">rad</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">radii</span><span class="p">(</span><span class="n">radii</span><span class="o">=</span><span class="n">radii</span><span class="p">)</span> <span class="o">+</span> \
                           <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span><span class="o">.</span><span class="n">radii</span><span class="p">(</span><span class="n">radii</span><span class="o">=</span><span class="n">radii</span><span class="p">))</span>
            
            <span class="c"># Update the coordinate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ia</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">bv</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="n">rad</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">(</span><span class="s">&#39;Changing bond-length dependent on several lacks implementation.&#39;</span><span class="p">)</span>
            
</div>
<div class="viewcode-block" id="Geometry.close"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">xyz_ia</span><span class="p">,</span><span class="n">dR</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">idx</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">ret_coord</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">ret_dist</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns supercell atomic indices for all atoms connecting to ``xyz_ia``</span>

<span class="sd">        This heavily relies on the ``self.close_sc`` method.</span>

<span class="sd">        Note that if a connection is made in a neighbouring super-cell</span>
<span class="sd">        then the atomic index is shifted by the super-cell index times</span>
<span class="sd">        number of atoms.</span>
<span class="sd">        This allows one to decipher super-cell atoms from unit-cell atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz_ia  : coordinate/index</span>
<span class="sd">            Either a point in space or an index of an atom.</span>
<span class="sd">            If an index is passed it is the equivalent of passing</span>
<span class="sd">            the atomic coordinate ``self.close_sc(self.xyz[xyz_ia,:])``.</span>
<span class="sd">        dR      : (None), float/tuple of float</span>
<span class="sd">            The radii parameter to where the atomic connections are found.</span>
<span class="sd">            If ``dR`` is an array it will return the indices:</span>
<span class="sd">            in the ranges:</span>
<span class="sd">               ``( x &lt;= dR[0] , dR[0] &lt; x &lt;= dR[1], dR[1] &lt; x &lt;= dR[2] )``</span>
<span class="sd">            If a single float it will return:</span>
<span class="sd">               ``x &lt;= dR``</span>
<span class="sd">        idx     : (None), array_like</span>
<span class="sd">            List of indices for atoms that are to be considered</span>
<span class="sd">        ret_coord : (False), boolean</span>
<span class="sd">            If true this method will return the coordinates </span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_dist : (False), boolean</span>
<span class="sd">            If true this method will return the distances from the ``xyz_ia`` </span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Convert to actual array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">idx</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ret_coord</span><span class="p">:</span> 
            <span class="n">c</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_dist</span><span class="p">:</span> 
            <span class="n">d</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">ret_special</span> <span class="o">=</span> <span class="n">ret_coord</span> <span class="ow">or</span> <span class="n">ret_dist</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">):</span>
            <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="n">s</span>
            <span class="n">sret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close_sc</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">s</span><span class="p">,:],</span><span class="n">dR</span><span class="o">=</span><span class="n">dR</span><span class="p">,</span><span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span><span class="n">ret_coord</span><span class="o">=</span><span class="n">ret_coord</span><span class="p">,</span><span class="n">ret_dist</span><span class="o">=</span><span class="n">ret_dist</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ret_special</span><span class="p">:</span> <span class="n">sret</span> <span class="o">=</span> <span class="p">(</span><span class="n">sret</span><span class="p">,)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">list</span><span class="p">):</span>
                <span class="c"># we have a list of arrays</span>
                <span class="k">if</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">na</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">ret_coord</span><span class="p">:</span> <span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">sret</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">ret_dist</span><span class="p">:</span> <span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">sret</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">x</span> <span class="o">+</span> <span class="n">na</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">ret_coord</span><span class="p">:</span> <span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">sret</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
                        <span class="k">if</span> <span class="n">ret_dist</span><span class="p">:</span> <span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">sret</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># We can add it to the list</span>
                <span class="c"># We add the atomic offset for the supercell index</span>
                <span class="k">if</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">na</span>
                    <span class="k">if</span> <span class="n">ret_coord</span><span class="p">:</span> <span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">sret</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">ret_dist</span><span class="p">:</span> <span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">sret</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">na</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_coord</span><span class="p">:</span> <span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">c</span><span class="p">],</span><span class="n">sret</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">ret_dist</span><span class="p">:</span> <span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">d</span><span class="p">],</span><span class="n">sret</span><span class="p">[</span><span class="n">d</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">ret_special</span><span class="p">:</span> <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># Hence ``close_all`` has exact meaning</span>
    <span class="c"># but ``close`` is shorten and retains meaning</span></div>
    <span class="n">close_all</span> <span class="o">=</span> <span class="n">close</span>


<div class="viewcode-block" id="Geometry.a2o"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.a2o">[docs]</a>    <span class="k">def</span> <span class="nf">a2o</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ia</span><span class="p">,</span><span class="nb">all</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an orbital index of the first orbital of said atom.</span>
<span class="sd">        This is particularly handy if you want to create</span>
<span class="sd">        TB models with more than one orbital per atom.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ia : list, int</span>
<span class="sd">             Atomic indices</span>
<span class="sd">        all: False, bool</span>
<span class="sd">             `False`, return only the first orbital corresponding to the atom,</span>
<span class="sd">             `True`, returns list of the full atom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">ia</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">ia</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span>
        <span class="n">oe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c"># Create ranges</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">oe</span><span class="o">-</span><span class="n">ob</span><span class="p">)],</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ob</span><span class="p">)):</span>
            <span class="n">o</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="n">oe</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">ob</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ob</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">oe</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="n">oe</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">ob</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">o</span>

</div>
<div class="viewcode-block" id="Geometry.o2a"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.o2a">[docs]</a>    <span class="k">def</span> <span class="nf">o2a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">io</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an atomic index corresponding to the orbital indicies.</span>

<span class="sd">        This is a particurlaly slow algorithm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        io: list, int</span>
<span class="sd">             List of indices to return the atoms for</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rlasto</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">iio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">io</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">rlasto</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iio</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="n">io</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>

</div>
<div class="viewcode-block" id="Geometry.sc2uc"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.sc2uc">[docs]</a>    <span class="k">def</span> <span class="nf">sc2uc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atoms</span><span class="p">,</span><span class="n">uniq</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns atoms from super-cell indices to unit-cell indices, possibly removing dublicates &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">uniq</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span> <span class="n">atoms</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">atoms</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span></div>
    <span class="n">asc2uc</span> <span class="o">=</span> <span class="n">sc2uc</span>


<div class="viewcode-block" id="Geometry.osc2uc"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.osc2uc">[docs]</a>    <span class="k">def</span> <span class="nf">osc2uc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">orbs</span><span class="p">,</span><span class="n">uniq</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns orbitals from super-cell indices to unit-cell indices, possibly removing dublicates &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">uniq</span><span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span> <span class="n">orbs</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">orbs</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>

</div>
<div class="viewcode-block" id="Geometry.a2isc"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.a2isc">[docs]</a>    <span class="k">def</span> <span class="nf">a2isc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the super-cell index for a specific atom</span>

<span class="sd">        Hence one can easily figure out the supercell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">idx</span><span class="p">,:]</span>

</div>
<div class="viewcode-block" id="Geometry.o2isc"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.o2isc">[docs]</a>    <span class="k">def</span> <span class="nf">o2isc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">o</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the super-cell index for a specific orbital.</span>

<span class="sd">        Hence one can easily figure out the supercell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">o</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">idx</span><span class="p">,:]</span>

    </div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Geometry.ase"><a class="viewcode-back" href="../../sids.geometry.html#sids.geometry.Geometry.ase">[docs]</a>    <span class="k">def</span> <span class="nf">ase</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span><span class="n">aseg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns geometry from an ASE object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        aseg : ASE `Atoms` object which contains the following routines:</span>
<span class="sd">            `get_atomic_numbers`, `get_positions`, `get_cell`.</span>
<span class="sd">            From those methods a `sids` object will be created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">aseg</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">()</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">aseg</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">aseg</span><span class="o">.</span><span class="n">get_cell</span><span class="p">()</span>
        <span class="c"># Convert to sids object</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="n">atoms</span><span class="o">=</span><span class="n">Z</span><span class="p">,</span><span class="n">sc</span><span class="o">=</span><span class="n">cell</span><span class="p">)</span>

    <span class="c"># same method name</span></div>
    <span class="n">ASE</span> <span class="o">=</span> <span class="n">ase</span>
    <span class="n">toase</span> <span class="o">=</span> <span class="n">ase</span>
    <span class="n">toASE</span> <span class="o">=</span> <span class="n">ase</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Geometry</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">same</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sc</span>
        <span class="n">same</span> <span class="o">=</span> <span class="n">same</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">same</span> <span class="o">=</span> <span class="n">same</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">same</span>

    
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>


    <span class="c"># Create pickling routines</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the state of this object &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s">&#39;xyz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span>
        <span class="n">d</span><span class="p">[</span><span class="s">&#39;atoms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">return</span> <span class="n">d</span>

    
    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Re-create the state of this object &quot;&quot;&quot;</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;xyz&#39;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;atoms&#39;</span><span class="p">],</span><span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">math</span> <span class="kn">as</span> <span class="nn">m</span>
    <span class="kn">from</span> <span class="nn">.geom.default</span> <span class="kn">import</span> <span class="n">diamond</span>
    
    <span class="c"># Get a diamond</span>
    <span class="n">dia</span> <span class="o">=</span> <span class="n">diamond</span><span class="p">()</span>

    <span class="c"># Print all closest atoms</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Atom&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
        <span class="n">dia</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="o">=</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">dia</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dia</span><span class="o">.</span><span class="n">dR</span><span class="p">))</span>

    <span class="c"># Print all closest atoms and distances</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Atom and distance&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
        <span class="n">dia</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="o">=</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">dia</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dia</span><span class="o">.</span><span class="n">dR</span><span class="p">,</span><span class="n">ret_dist</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>

    <span class="c"># Print all closest atoms and coords</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Atom and coords&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
        <span class="n">dia</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="o">=</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">dia</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dia</span><span class="o">.</span><span class="n">dR</span><span class="p">,</span><span class="n">ret_coord</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>

    <span class="c"># Print all closest atoms, coords and distances</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Atom and coords and distances&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
        <span class="n">dia</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="o">=</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">dia</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dia</span><span class="o">.</span><span class="n">dR</span><span class="p">,</span><span class="n">ret_coord</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">ret_dist</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>


    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Orbital indices&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">dia</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">dia</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

    <span class="c"># Lets try and create a big one and cut it</span>
    <span class="n">big</span> <span class="o">=</span> <span class="n">dia</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Big stuff&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">big</span><span class="p">)</span>
    <span class="n">half</span> <span class="o">=</span> <span class="n">big</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Small stuff&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">half</span><span class="p">)</span>


    <span class="n">big</span> <span class="o">=</span> <span class="n">dia</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Iterable loop: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">big</span><span class="p">)))</span>
    <span class="n">na</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">big</span><span class="p">:</span>
        <span class="n">na</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Completed with: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">na</span><span class="p">))</span>

    <span class="n">big</span> <span class="o">=</span> <span class="n">dia</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Iterable loop: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">big</span><span class="p">)))</span>
    <span class="n">na</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">big</span><span class="o">.</span><span class="n">iter_block</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">na</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ias</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Completed with: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">na</span><span class="p">))</span>

    <span class="c"># Try the rotation</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">dia</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">rot</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span><span class="n">rot</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="n">rot</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span><span class="n">rot</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>

    <span class="c"># Try the rotation</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">dia</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">rot</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span><span class="n">rot</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">only</span><span class="o">=</span><span class="s">&#39;cell&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">rot</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span><span class="n">rot</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>

    <span class="c"># Try and align Miller indices</span>
    <span class="n">fcc</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">]),</span><span class="n">atoms</span><span class="o">=</span><span class="n">Atom</span><span class="p">[</span><span class="s">&#39;Fe&#39;</span><span class="p">],</span>
                   <span class="n">sc</span><span class="o">=</span><span class="n">SuperCell</span><span class="p">([[</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
                                 <span class="p">[</span> <span class="mf">0.5</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
                                 <span class="p">[</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">]]))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">fcc</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">fcc</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">fcc</span><span class="o">.</span><span class="n">rotate_miller</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">rot</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>

    <span class="c"># Try the passing of an actual SuperCell</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">]),</span><span class="n">atoms</span><span class="o">=</span><span class="n">Atom</span><span class="p">[</span><span class="s">&#39;Fe&#39;</span><span class="p">],</span><span class="n">sc</span><span class="o">=</span><span class="n">fcc</span><span class="o">.</span><span class="n">sc</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Nick R. Papior.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.4.4
',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>