<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sisl.geometry module &mdash; sisl |release| documentation</title>
    
    <link rel="stylesheet" href="_static/scrolls.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.6.1
',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="sisl |release| documentation" href="index.html" /> 
  </head>
  <body role="document">
    <div id="content">
      <div class="header">
        <h1 class="heading"><a href="index.html"
          title="back to the documentation overview"><span>sisl.geometry module</span></a></h1>
      </div>
      <div class="relnav" role="navigation" aria-label="related navigation">
        <a href="#">sisl.geometry module</a>
      </div>
      <div id="contentwrapper">
        
  <div class="section" id="module-sisl.geometry">
<span id="sisl-geometry-module"></span><h1>sisl.geometry module<a class="headerlink" href="#module-sisl.geometry" title="Permalink to this headline">¶</a></h1>
<p>Geometry class to retain the atomic structure.</p>
<dl class="class">
<dt id="sisl.geometry.Geometry">
<em class="property">class </em><code class="descclassname">sisl.geometry.</code><code class="descname">Geometry</code><span class="sig-paren">(</span><em>xyz</em>, <em>atoms=H orbs: 1 mass(au): 1.00794</em>, <em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCellChild" title="sisl.supercell.SuperCellChild"><code class="xref py py-class docutils literal"><span class="pre">sisl.supercell.SuperCellChild</span></code></a></p>
<p>Holds atomic information, coordinates, species, lattice vectors</p>
<p>The <a class="reference internal" href="#sisl.geometry.Geometry" title="sisl.geometry.Geometry"><code class="xref any py py-class docutils literal"><span class="pre">Geometry</span></code></a> class holds information regarding atomic coordinates,
the atomic species, the corresponding lattice-vectors.</p>
<p>It enables the interaction and conversion of atomic structures via
simple routine methods.</p>
<p>All lengths are assumed to be in units of Angstrom, however, as
long as units are kept same the exact units are irrespective.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz</strong> : array_like</p>
<blockquote>
<div><p>atomic coordinates
<code class="docutils literal"><span class="pre">xyz[i,:]</span></code> is the atomic coordinate of the i&#8217;th atom.</p>
</div></blockquote>
<p><strong>atoms</strong> : array_like</p>
<blockquote>
<div><p>atomic species retrieved from the <a class="reference internal" href="sisl.atom.html#sisl.atom.PeriodicTable" title="sisl.atom.PeriodicTable"><code class="xref any py py-class docutils literal"><span class="pre">PeriodicTable</span></code></a></p>
</div></blockquote>
<p><strong>sc</strong> : <a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a></p>
<blockquote class="last">
<div><p>the unit-cell describing the atoms in a periodic
super-cell</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>An atomic lattice consisting of Hydrogen atoms.
An atomic square lattice of Hydrogen atoms</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">           [1, 1, 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="n">Atom</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">],</span><span class="n">sc</span><span class="p">)</span>
</pre></div>
</div>
<p>The following estimates the lattice vectors from the
atomic coordinates, although possible, it is not recommended
to be used.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">           [1, 1, 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="n">Atom</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.dR" title="sisl.geometry.Geometry.dR"><code class="xref py py-obj docutils literal"><span class="pre">dR</span></code></a></td>
<td>Returns the maximum orbital range of the atoms</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>na</td>
<td>(int) number of atoms, <code class="docutils literal"><span class="pre">len(self)</span></code></td>
</tr>
<tr class="row-even"><td>xyz</td>
<td>(ndarray) atomic coordinates</td>
</tr>
<tr class="row-odd"><td>atoms</td>
<td>(array_like, <a class="reference internal" href="sisl.atom.html#sisl.atom.Atom" title="sisl.atom.Atom"><code class="xref any py py-class docutils literal"><span class="pre">Atom</span></code></a>) the atomic objects associated with each atom</td>
</tr>
<tr class="row-even"><td>sc</td>
<td>(<a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a>) the supercell describing the periodicity of the geometry</td>
</tr>
<tr class="row-odd"><td>no: int</td>
<td>total number of orbitals in the geometry</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.ASE" title="sisl.geometry.Geometry.ASE"><code class="xref py py-obj docutils literal"><span class="pre">ASE</span></code></a>(aseg)</td>
<td>Returns geometry from an ASE object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.a2isc" title="sisl.geometry.Geometry.a2isc"><code class="xref py py-obj docutils literal"><span class="pre">a2isc</span></code></a>(a)</td>
<td>Returns the super-cell index for a specific atom</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.a2o" title="sisl.geometry.Geometry.a2o"><code class="xref py py-obj docutils literal"><span class="pre">a2o</span></code></a>(ia[,&nbsp;all])</td>
<td>Returns an orbital index of the first orbital of said atom.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.append" title="sisl.geometry.Geometry.append"><code class="xref py py-obj docutils literal"><span class="pre">append</span></code></a>(other,&nbsp;axis)</td>
<td>Appends structure along <code class="docutils literal"><span class="pre">axis</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.asc2uc" title="sisl.geometry.Geometry.asc2uc"><code class="xref py py-obj docutils literal"><span class="pre">asc2uc</span></code></a>(atoms[,&nbsp;uniq])</td>
<td>Returns atoms from super-cell indices to unit-cell indices, possibly removing dublicates</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.axyzsc" title="sisl.geometry.Geometry.axyzsc"><code class="xref py py-obj docutils literal"><span class="pre">axyzsc</span></code></a>(ia)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.bond_correct" title="sisl.geometry.Geometry.bond_correct"><code class="xref py py-obj docutils literal"><span class="pre">bond_correct</span></code></a>(ia,&nbsp;atoms[,&nbsp;radii])</td>
<td>Corrects the bond between <code class="xref any docutils literal"><span class="pre">ia</span></code> and the <code class="xref any docutils literal"><span class="pre">atoms</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.center" title="sisl.geometry.Geometry.center"><code class="xref py py-obj docutils literal"><span class="pre">center</span></code></a>([atoms,&nbsp;which])</td>
<td>Returns the center of the geometry</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.close" title="sisl.geometry.Geometry.close"><code class="xref py py-obj docutils literal"><span class="pre">close</span></code></a>(xyz_ia[,&nbsp;dR,&nbsp;idx,&nbsp;ret_coord,&nbsp;ret_dist])</td>
<td>Returns supercell atomic indices for all atoms connecting to <code class="docutils literal"><span class="pre">xyz_ia</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.close_all" title="sisl.geometry.Geometry.close_all"><code class="xref py py-obj docutils literal"><span class="pre">close_all</span></code></a>(xyz_ia[,&nbsp;dR,&nbsp;idx,&nbsp;ret_coord,&nbsp;ret_dist])</td>
<td>Returns supercell atomic indices for all atoms connecting to <code class="docutils literal"><span class="pre">xyz_ia</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.close_sc" title="sisl.geometry.Geometry.close_sc"><code class="xref py py-obj docutils literal"><span class="pre">close_sc</span></code></a>(xyz_ia[,&nbsp;isc,&nbsp;dR,&nbsp;idx,&nbsp;ret_coord,&nbsp;...])</td>
<td>Calculates which atoms are close to some atom or point in space, only returns so relative to a super-cell.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.coords" title="sisl.geometry.Geometry.coords"><code class="xref py py-obj docutils literal"><span class="pre">coords</span></code></a>([isc,&nbsp;idx])</td>
<td>Returns the coordinates of a given super-cell index</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.copy" title="sisl.geometry.Geometry.copy"><code class="xref py py-obj docutils literal"><span class="pre">copy</span></code></a>()</td>
<td>Returns a copy of the object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.cut" title="sisl.geometry.Geometry.cut"><code class="xref py py-obj docutils literal"><span class="pre">cut</span></code></a>(seps,&nbsp;axis[,&nbsp;seg,&nbsp;rtol,&nbsp;atol])</td>
<td>Returns a subset of atoms from the geometry by cutting the geometry into <code class="docutils literal"><span class="pre">seps</span></code> parts along the direction <code class="docutils literal"><span class="pre">axis</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.insert" title="sisl.geometry.Geometry.insert"><code class="xref py py-obj docutils literal"><span class="pre">insert</span></code></a>(atom,&nbsp;other)</td>
<td>Inserts other atoms right before index</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">is_orthogonal</span></code>()</td>
<td>Return true if all cell vectors are linearly independent</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.iter_block" title="sisl.geometry.Geometry.iter_block"><code class="xref py py-obj docutils literal"><span class="pre">iter_block</span></code></a>([iR,&nbsp;dR])</td>
<td>Returns an iterator for performance critical looping.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.iter_linear" title="sisl.geometry.Geometry.iter_linear"><code class="xref py py-obj docutils literal"><span class="pre">iter_linear</span></code></a>()</td>
<td>Returns an iterator for simple linear ranges.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.iter_species" title="sisl.geometry.Geometry.iter_species"><code class="xref py py-obj docutils literal"><span class="pre">iter_species</span></code></a>()</td>
<td>Returns an iterator over all atoms and species as a tuple in this geometry</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.mirror" title="sisl.geometry.Geometry.mirror"><code class="xref py py-obj docutils literal"><span class="pre">mirror</span></code></a>(plane[,&nbsp;atoms])</td>
<td>Mirrors the structure around the center of the atoms</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.o2a" title="sisl.geometry.Geometry.o2a"><code class="xref py py-obj docutils literal"><span class="pre">o2a</span></code></a>(io)</td>
<td>Returns an atomic index corresponding to the orbital indicies.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.o2isc" title="sisl.geometry.Geometry.o2isc"><code class="xref py py-obj docutils literal"><span class="pre">o2isc</span></code></a>(o)</td>
<td>Returns the super-cell index for a specific orbital.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.osc2uc" title="sisl.geometry.Geometry.osc2uc"><code class="xref py py-obj docutils literal"><span class="pre">osc2uc</span></code></a>(orbs[,&nbsp;uniq])</td>
<td>Returns orbitals from super-cell indices to unit-cell indices, possibly removing dublicates</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.read" title="sisl.geometry.Geometry.read"><code class="xref py py-obj docutils literal"><span class="pre">read</span></code></a>(sile)</td>
<td>Reads geometry from the <a class="reference internal" href="sisl.io.html#sisl.io.Sile" title="sisl.io.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> using <code class="xref any docutils literal"><span class="pre">Sile.read_geom</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.remove" title="sisl.geometry.Geometry.remove"><code class="xref py py-obj docutils literal"><span class="pre">remove</span></code></a>(atoms)</td>
<td>Remove atoms from the geometry.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.repeat" title="sisl.geometry.Geometry.repeat"><code class="xref py py-obj docutils literal"><span class="pre">repeat</span></code></a>(reps,&nbsp;axis)</td>
<td>Returns a geometry repeated, i.e.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.reverse" title="sisl.geometry.Geometry.reverse"><code class="xref py py-obj docutils literal"><span class="pre">reverse</span></code></a>([atoms])</td>
<td>Returns a reversed geometry</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.rotate" title="sisl.geometry.Geometry.rotate"><code class="xref py py-obj docutils literal"><span class="pre">rotate</span></code></a>(angle,&nbsp;v[,&nbsp;only,&nbsp;degree])</td>
<td>Rotates the geometry, in-place by the angle around the vector</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.rotate_miller" title="sisl.geometry.Geometry.rotate_miller"><code class="xref py py-obj docutils literal"><span class="pre">rotate_miller</span></code></a>(m,&nbsp;v)</td>
<td>Align Miller direction along <code class="docutils literal"><span class="pre">v</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.rotatea" title="sisl.geometry.Geometry.rotatea"><code class="xref py py-obj docutils literal"><span class="pre">rotatea</span></code></a>(angle[,&nbsp;only,&nbsp;degree])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.rotateb" title="sisl.geometry.Geometry.rotateb"><code class="xref py py-obj docutils literal"><span class="pre">rotateb</span></code></a>(angle[,&nbsp;only,&nbsp;degree])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.rotatec" title="sisl.geometry.Geometry.rotatec"><code class="xref py py-obj docutils literal"><span class="pre">rotatec</span></code></a>(angle[,&nbsp;only,&nbsp;degree])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.sc2uc" title="sisl.geometry.Geometry.sc2uc"><code class="xref py py-obj docutils literal"><span class="pre">sc2uc</span></code></a>(atoms[,&nbsp;uniq])</td>
<td>Returns atoms from super-cell indices to unit-cell indices, possibly removing dublicates</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">sc_index</span></code>(*args,&nbsp;**kwargs)</td>
<td>Call local <a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a> object <a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell.sc_index" title="sisl.supercell.SuperCell.sc_index"><code class="xref any py py-meth docutils literal"><span class="pre">sc_index</span></code></a> function</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_nsc</span></code>(nsc)</td>
<td>Set the number of super-cells in the <a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a> object</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_sc</span></code>(sc)</td>
<td>Overwrites the local supercell</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_supercell</span></code>(sc)</td>
<td>Overwrites the local supercell</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.sub" title="sisl.geometry.Geometry.sub"><code class="xref py py-obj docutils literal"><span class="pre">sub</span></code></a>(atoms[,&nbsp;cell])</td>
<td>Returns a subset of atoms from the geometry.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.swap" title="sisl.geometry.Geometry.swap"><code class="xref py py-obj docutils literal"><span class="pre">swap</span></code></a>(a,&nbsp;b)</td>
<td>Returns a geometry with swapped atoms</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.swapaxes" title="sisl.geometry.Geometry.swapaxes"><code class="xref py py-obj docutils literal"><span class="pre">swapaxes</span></code></a>(a,&nbsp;b[,&nbsp;swap])</td>
<td>Returns geometry with swapped axis</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.tile" title="sisl.geometry.Geometry.tile"><code class="xref py py-obj docutils literal"><span class="pre">tile</span></code></a>(reps,&nbsp;axis)</td>
<td>Returns a geometry tiled, i.e.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.toASE" title="sisl.geometry.Geometry.toASE"><code class="xref py py-obj docutils literal"><span class="pre">toASE</span></code></a>()</td>
<td>Returns the geometry as an ASE <code class="docutils literal"><span class="pre">Atoms</span></code> object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.translate" title="sisl.geometry.Geometry.translate"><code class="xref py py-obj docutils literal"><span class="pre">translate</span></code></a>(v[,&nbsp;atoms,&nbsp;cell])</td>
<td>Translates the geometry by <code class="docutils literal"><span class="pre">v</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.write" title="sisl.geometry.Geometry.write"><code class="xref py py-obj docutils literal"><span class="pre">write</span></code></a>(sile,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Writes geometry to the <a class="reference internal" href="sisl.io.html#sisl.io.Sile" title="sisl.io.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> using <code class="xref any docutils literal"><span class="pre">sile.write_geom</span></code></td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="sisl.geometry.Geometry.ASE">
<em class="property">classmethod </em><code class="descname">ASE</code><span class="sig-paren">(</span><em>aseg</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.ASE" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns geometry from an ASE object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>aseg</strong> : ASE <code class="docutils literal"><span class="pre">Atoms</span></code> object which contains the following routines:</p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">get_atomic_numbers</span></code>, <code class="docutils literal"><span class="pre">get_positions</span></code>, <code class="docutils literal"><span class="pre">get_cell</span></code>.
From those methods a <a class="reference internal" href="sisl.html"><span class="doc">sisl package</span></a> object will be created.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.a2isc">
<code class="descname">a2isc</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.a2isc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the super-cell index for a specific atom</p>
<p>Hence one can easily figure out the supercell</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.a2o">
<code class="descname">a2o</code><span class="sig-paren">(</span><em>ia</em>, <em>all=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.a2o" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an orbital index of the first orbital of said atom.
This is particularly handy if you want to create
TB models with more than one orbital per atom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ia</strong> : list, int</p>
<blockquote>
<div><p>Atomic indices</p>
</div></blockquote>
<p><strong>all: False, bool</strong></p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">False</span></code>, return only the first orbital corresponding to the atom,
<code class="docutils literal"><span class="pre">True</span></code>, returns list of the full atom</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>other</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends structure along <code class="docutils literal"><span class="pre">axis</span></code>. This will automatically
add the <code class="docutils literal"><span class="pre">self.cell[axis,:]</span></code> to all atomic coordiates in the
<code class="docutils literal"><span class="pre">other</span></code> structure before appending.</p>
<p>The basic algorithm is this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oxa</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:][</span><span class="kc">None</span><span class="p">,:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span><span class="n">oxa</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">lasto</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">lasto</span><span class="p">)</span>
</pre></div>
</div>
<p>NOTE: The cell appended is only in the axis that
is appended, which means that the other cell directions
need not conform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>other</strong> : <a class="reference internal" href="#sisl.geometry.Geometry" title="sisl.geometry.Geometry"><code class="xref any py py-class docutils literal"><span class="pre">Geometry</span></code></a>/<a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a></p>
<blockquote>
<div><p>Other geometry class which needs to be appended
If a <a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a> only the super cell will be extended</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote class="last">
<div><p>Cell direction to which the <code class="docutils literal"><span class="pre">other</span></code> geometry should be
appended.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.asc2uc">
<code class="descname">asc2uc</code><span class="sig-paren">(</span><em>atoms</em>, <em>uniq=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.asc2uc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns atoms from super-cell indices to unit-cell indices, possibly removing dublicates</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.axyzsc">
<code class="descname">axyzsc</code><span class="sig-paren">(</span><em>ia</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.axyzsc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.bond_correct">
<code class="descname">bond_correct</code><span class="sig-paren">(</span><em>ia</em>, <em>atoms</em>, <em>radii='calc'</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.bond_correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Corrects the bond between <code class="xref any docutils literal"><span class="pre">ia</span></code> and the <code class="xref any docutils literal"><span class="pre">atoms</span></code>.</p>
<p>Corrects the bond-length between atom <code class="xref any docutils literal"><span class="pre">ia</span></code> and <code class="xref any docutils literal"><span class="pre">atoms</span></code> in such
a way that the atomic radii is preserved.
I.e. the sum of the bond-lengths minimizes the distance matrix.</p>
<p>Only atom <code class="xref any docutils literal"><span class="pre">ia</span></code> is moved.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ia</strong> : int</p>
<blockquote>
<div><p>The atom to be displaced according to the atomic radii</p>
</div></blockquote>
<p><strong>atoms</strong> : int, array_like</p>
<blockquote>
<div><p>The atom(s) from which the radii should be reduced.</p>
</div></blockquote>
<p><strong>radii</strong> : str/float</p>
<blockquote class="last">
<div><p>If str will use that as lookup in <a class="reference internal" href="sisl.atom.html#sisl.atom.Atom.radii" title="sisl.atom.Atom.radii"><code class="xref any py py-meth docutils literal"><span class="pre">Atom.radii</span></code></a>.
Else it will be the new bond-length.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>atoms=None</em>, <em>which='xyz'</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the center of the geometry</p>
<p>By specifying <code class="docutils literal"><span class="pre">which</span></code> one can control whether it should be:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xyz|position</span></code>: Center of coordinates (default)</li>
<li><code class="docutils literal"><span class="pre">mass</span></code>: Center of mass</li>
<li><code class="docutils literal"><span class="pre">cell</span></code>: Center of cell</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atoms</strong> : list, ndarray</p>
<blockquote>
<div><p>list of atomic indices to find center of</p>
</div></blockquote>
<p><strong>which</strong> : str</p>
<blockquote class="last">
<div><p>determine whether center should be of &#8216;cell&#8217;, mass-centered (&#8216;mass&#8217;),
or absolute center of the positions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.close">
<code class="descname">close</code><span class="sig-paren">(</span><em>xyz_ia</em>, <em>dR=None</em>, <em>idx=None</em>, <em>ret_coord=False</em>, <em>ret_dist=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns supercell atomic indices for all atoms connecting to <code class="docutils literal"><span class="pre">xyz_ia</span></code></p>
<p>This heavily relies on the <a class="reference internal" href="#sisl.geometry.Geometry.close_sc" title="sisl.geometry.Geometry.close_sc"><code class="xref any py py-meth docutils literal"><span class="pre">close_sc</span></code></a> method.</p>
<p>Note that if a connection is made in a neighbouring super-cell
then the atomic index is shifted by the super-cell index times
number of atoms.
This allows one to decipher super-cell atoms from unit-cell atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz_ia</strong> : coordinate/index</p>
<blockquote>
<div><p>Either a point in space or an index of an atom.
If an index is passed it is the equivalent of passing
the atomic coordinate <code class="xref any docutils literal"><span class="pre">close_sc(self.xyz[xyz_ia,:])</span></code>.</p>
</div></blockquote>
<p><strong>dR</strong> : (None), float/tuple of float</p>
<blockquote>
<div><p>The radii parameter to where the atomic connections are found.
If <code class="docutils literal"><span class="pre">dR</span></code> is an array it will return the indices:
in the ranges:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&gt;&gt;&gt; ``( x &lt;= dR[0] , dR[0] &lt; x &lt;= dR[1], dR[1] &lt; x &lt;= dR[2] )``
</pre></div>
</div>
<p>If a single float it will return:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&gt;&gt;&gt; ``x &lt;= dR``
</pre></div>
</div>
</div></blockquote>
<p><strong>idx</strong> : (None), array_like</p>
<blockquote>
<div><p>List of indices for atoms that are to be considered</p>
</div></blockquote>
<p><strong>ret_coord</strong> : (False), boolean</p>
<blockquote>
<div><p>If true this method will return the coordinates
for each of the couplings.</p>
</div></blockquote>
<p><strong>ret_dist</strong> : (False), boolean</p>
<blockquote class="last">
<div><p>If true this method will return the distances from the <code class="docutils literal"><span class="pre">xyz_ia</span></code>
for each of the couplings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.close_all">
<code class="descname">close_all</code><span class="sig-paren">(</span><em>xyz_ia</em>, <em>dR=None</em>, <em>idx=None</em>, <em>ret_coord=False</em>, <em>ret_dist=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.close_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns supercell atomic indices for all atoms connecting to <code class="docutils literal"><span class="pre">xyz_ia</span></code></p>
<p>This heavily relies on the <a class="reference internal" href="#sisl.geometry.Geometry.close_sc" title="sisl.geometry.Geometry.close_sc"><code class="xref any py py-meth docutils literal"><span class="pre">close_sc</span></code></a> method.</p>
<p>Note that if a connection is made in a neighbouring super-cell
then the atomic index is shifted by the super-cell index times
number of atoms.
This allows one to decipher super-cell atoms from unit-cell atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz_ia</strong> : coordinate/index</p>
<blockquote>
<div><p>Either a point in space or an index of an atom.
If an index is passed it is the equivalent of passing
the atomic coordinate <code class="xref any docutils literal"><span class="pre">close_sc(self.xyz[xyz_ia,:])</span></code>.</p>
</div></blockquote>
<p><strong>dR</strong> : (None), float/tuple of float</p>
<blockquote>
<div><p>The radii parameter to where the atomic connections are found.
If <code class="docutils literal"><span class="pre">dR</span></code> is an array it will return the indices:
in the ranges:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&gt;&gt;&gt; ``( x &lt;= dR[0] , dR[0] &lt; x &lt;= dR[1], dR[1] &lt; x &lt;= dR[2] )``
</pre></div>
</div>
<p>If a single float it will return:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&gt;&gt;&gt; ``x &lt;= dR``
</pre></div>
</div>
</div></blockquote>
<p><strong>idx</strong> : (None), array_like</p>
<blockquote>
<div><p>List of indices for atoms that are to be considered</p>
</div></blockquote>
<p><strong>ret_coord</strong> : (False), boolean</p>
<blockquote>
<div><p>If true this method will return the coordinates
for each of the couplings.</p>
</div></blockquote>
<p><strong>ret_dist</strong> : (False), boolean</p>
<blockquote class="last">
<div><p>If true this method will return the distances from the <code class="docutils literal"><span class="pre">xyz_ia</span></code>
for each of the couplings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.close_sc">
<code class="descname">close_sc</code><span class="sig-paren">(</span><em>xyz_ia, isc=[0, 0, 0], dR=None, idx=None, ret_coord=False, ret_dist=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.close_sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates which atoms are close to some atom or point
in space, only returns so relative to a super-cell.</p>
<p>This returns a set of atomic indices which are within a
sphere of radius <code class="docutils literal"><span class="pre">dR</span></code>.</p>
<p>If dR is a tuple/list/array it will return the indices:
in the ranges:
&gt;&gt;&gt; ( x &lt;= dR[0] , dR[0] &lt; x &lt;= dR[1], dR[1] &lt; x &lt;= dR[2] )</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz_ia</strong> : coordinate/index</p>
<blockquote>
<div><p>Either a point in space or an index of an atom.
If an index is passed it is the equivalent of passing
the atomic coordinate <code class="docutils literal"><span class="pre">close_sc(self.xyz[xyz_ia,:])</span></code>.</p>
</div></blockquote>
<p><strong>isc</strong> : ([0,0,0]), array_like, optional</p>
<blockquote>
<div><p>The super-cell which the coordinates are checked in.</p>
</div></blockquote>
<p><strong>dR</strong> : (None), float/tuple of float</p>
<blockquote>
<div><p>The radii parameter to where the atomic connections are found.
If <code class="docutils literal"><span class="pre">dR</span></code> is an array it will return the indices:
in the ranges:</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">dR[0]</span> <span class="pre">,</span> <span class="pre">dR[0]</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">dR[1],</span> <span class="pre">dR[1]</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">dR[2]</span> <span class="pre">)</span></code></p>
</div></blockquote>
<dl class="docutils">
<dt>If a single float it will return:</dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">dR</span></code></p>
</dd>
</dl>
</div></blockquote>
<p><strong>idx</strong> : (None), array_like</p>
<blockquote>
<div><p>List of atoms that will be considered. This can
be used to only take out a certain atoms.</p>
</div></blockquote>
<p><strong>ret_coord</strong> : (False), boolean</p>
<blockquote>
<div><p>If true this method will return the coordinates
for each of the couplings.</p>
</div></blockquote>
<p><strong>ret_dist</strong> : (False), boolean</p>
<blockquote class="last">
<div><p>If true this method will return the distance
for each of the couplings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.coords">
<code class="descname">coords</code><span class="sig-paren">(</span><em>isc=[0, 0, 0], idx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coordinates of a given super-cell index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>isc</strong> : array_like</p>
<blockquote>
<div><p>Returns the atomic coordinates shifted according to the integer
parts of the cell.</p>
</div></blockquote>
<p><strong>idx</strong> : int/array_like</p>
<blockquote class="last">
<div><p>Only return the coordinates of these indices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">]],</span><span class="n">xyz</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">isc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[[ 1.   0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the object.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.cut">
<code class="descname">cut</code><span class="sig-paren">(</span><em>seps</em>, <em>axis</em>, <em>seg=0</em>, <em>rtol=0.0001</em>, <em>atol=0.0001</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a subset of atoms from the geometry by cutting the
geometry into <code class="docutils literal"><span class="pre">seps</span></code> parts along the direction <code class="docutils literal"><span class="pre">axis</span></code>.
It will then _only_ return the first cut.</p>
<p>This will effectively change the unit-cell in the <code class="docutils literal"><span class="pre">axis</span></code> as-well
as removing <code class="docutils literal"><span class="pre">self.na_u/seps</span></code> atoms.
It requires that <code class="docutils literal"><span class="pre">self.na_u</span> <span class="pre">%</span> <span class="pre">seps</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p>
<p>REMARK: You need to ensure that all atoms within the first
cut out region are within the primary unit-cell.</p>
<p>Doing <code class="docutils literal"><span class="pre">geom.cut(2,1).tile(reps=2,axis=1)</span></code>, could for symmetric setups,
be equivalent to a no-op operation. A <code class="docutils literal"><span class="pre">UserWarning</span></code> will be issued
if this is not the case.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axis</strong> : int</p>
<blockquote>
<div><p>the axis that will be cut</p>
</div></blockquote>
<p><strong>seps</strong> : int</p>
<blockquote>
<div><p>number of times the structure will be cut.</p>
</div></blockquote>
<p><strong>seg</strong> : int, optional (0)</p>
<blockquote>
<div><p>returns the i&#8217;th segment of the cut structure
Currently the atomic coordinates are not translated,
this may change in the future.</p>
</div></blockquote>
<p><strong>rtol</strong> : (tolerance for checking tiling, see <code class="docutils literal"><span class="pre">numpy.allclose</span></code>)</p>
<p class="last"><strong>atol</strong> : (tolerance for checking tiling, see <code class="docutils literal"><span class="pre">numpy.allclose</span></code>)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.geometry.Geometry.dR">
<code class="descname">dR</code><a class="headerlink" href="#sisl.geometry.Geometry.dR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum orbital range of the atoms</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>atom</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts other atoms right before index</p>
<p>We insert the <code class="docutils literal"><span class="pre">other</span></code> <a class="reference internal" href="#sisl.geometry.Geometry" title="sisl.geometry.Geometry"><code class="xref any py py-class docutils literal"><span class="pre">Geometry</span></code></a> before obj</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.iter_block">
<code class="descname">iter_block</code><span class="sig-paren">(</span><em>iR=10</em>, <em>dR=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.iter_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator for performance critical looping.</p>
<p>NOTE: This requires that dR has been set correctly as the maximum interaction range.</p>
<p>I.e. the loop would look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">iter_block</span><span class="p">():</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ias</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="n">idx_a</span> <span class="o">=</span> <span class="n">dev</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">dR</span> <span class="o">=</span> <span class="n">dR</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">)</span>
</pre></div>
</div>
<p>This iterator is intended for systems with more than 1000 atoms.</p>
<p>Remark that the iterator used is non-deterministic, i.e. any two iterators need
not return the same atoms in any way.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>iR</strong> : (10) integer</p>
<blockquote>
<div><p>the number of <code class="docutils literal"><span class="pre">dR</span></code> ranges taken into account when doing the iterator</p>
</div></blockquote>
<p><strong>dR</strong> : (self.dR), float</p>
<blockquote>
<div><p>enables overwriting the local dR quantity.</p>
</div></blockquote>
<p><strong>Returns two lists with [0] being a list of atoms to be looped and [1] being the atoms that</strong></p>
<p class="last"><strong>need searched.</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.iter_linear">
<code class="descname">iter_linear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.iter_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator for simple linear ranges.</p>
<p>This iterator is the same as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="o">&lt;</span><span class="n">do</span> <span class="n">something</span><span class="o">&gt;</span>
</pre></div>
</div>
<dl class="docutils">
<dt>or equivalently</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="o">&lt;</span><span class="n">do</span> <span class="n">something</span><span class="o">&gt;</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.iter_species">
<code class="descname">iter_species</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.iter_species" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over all atoms and species as a tuple in this geometry</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">idx_specie</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_species</span><span class="p">():</span>
</pre></div>
</div>
<p>with <code class="docutils literal"><span class="pre">ia</span></code> being the atomic index, <code class="docutils literal"><span class="pre">a</span></code> the <a class="reference internal" href="sisl.atom.html#sisl.atom.Atom" title="sisl.atom.Atom"><code class="xref any py py-class docutils literal"><span class="pre">Atom</span></code></a> object, <code class="xref any docutils literal"><span class="pre">idx_specie</span></code>
is the index of the species</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.mirror">
<code class="descname">mirror</code><span class="sig-paren">(</span><em>plane</em>, <em>atoms=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Mirrors the structure around the center of the atoms</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.geometry.Geometry.no_s">
<code class="descname">no_s</code><a class="headerlink" href="#sisl.geometry.Geometry.no_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of supercell orbitals</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.o2a">
<code class="descname">o2a</code><span class="sig-paren">(</span><em>io</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.o2a" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an atomic index corresponding to the orbital indicies.</p>
<p>This is a particurlaly slow algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>io: list, int</strong></p>
<blockquote class="last">
<div><p>List of indices to return the atoms for</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.o2isc">
<code class="descname">o2isc</code><span class="sig-paren">(</span><em>o</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.o2isc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the super-cell index for a specific orbital.</p>
<p>Hence one can easily figure out the supercell</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.osc2uc">
<code class="descname">osc2uc</code><span class="sig-paren">(</span><em>orbs</em>, <em>uniq=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.osc2uc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns orbitals from super-cell indices to unit-cell indices, possibly removing dublicates</p>
</dd></dl>

<dl class="staticmethod">
<dt id="sisl.geometry.Geometry.read">
<em class="property">static </em><code class="descname">read</code><span class="sig-paren">(</span><em>sile</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads geometry from the <a class="reference internal" href="sisl.io.html#sisl.io.Sile" title="sisl.io.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> using <code class="xref any docutils literal"><span class="pre">Sile.read_geom</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sile</strong> : <a class="reference internal" href="sisl.io.html#sisl.io.Sile" title="sisl.io.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a>, str</p>
<blockquote class="last">
<div><p>a <a class="reference internal" href="sisl.io.html#sisl.io.Sile" title="sisl.io.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> object which will be used to read the geometry
if it is a string it will create a new sile using <a class="reference internal" href="sisl.io.html#sisl.io.get_sile" title="sisl.io.get_sile"><code class="xref any py py-func docutils literal"><span class="pre">get_sile</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>atoms</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove atoms from the geometry.</p>
<p>Indices passed <em>MUST</em> be unique.</p>
<p>Negative indices are wrapped and thus works.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atoms</strong> : array_like</p>
<blockquote class="last">
<div><p>indices of all atoms to be removed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><em>reps</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a geometry repeated, i.e. copied in a special way.</p>
<p>The atomic indices are <em>NOT</em> retained for the base structure.</p>
<p>The expansion of the atoms are basically performed using this
algorithm:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ja</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="n">ja</span> <span class="o">=</span> <span class="n">ia</span> <span class="o">+</span> <span class="n">cell</span><span class="p">[</span><span class="nb">id</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">i</span>
</pre></div>
</div>
<p>This method allows to utilise Bloch&#8217;s theorem when creating
tight-binding parameter sets for TBtrans.</p>
<p>For geometries with a single atom this routine returns the same as
<a class="reference internal" href="#sisl.geometry.Geometry.tile" title="sisl.geometry.Geometry.tile"><code class="xref any py py-meth docutils literal"><span class="pre">tile</span></code></a>.</p>
<p>It is adviced to only use this for electrode Bloch&#8217;s theorem
purposes as <a class="reference internal" href="#sisl.geometry.Geometry.tile" title="sisl.geometry.Geometry.tile"><code class="xref any py py-meth docutils literal"><span class="pre">tile</span></code></a> is faster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reps</strong> : number of repetitions</p>
<p><strong>axis</strong> : direction of repetition</p>
<blockquote class="last">
<div><p>0, 1, 2 according to the cell-direction</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">]],</span><span class="n">xyz</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">[[ 0.   0.   0. ]</span>
<span class="go"> [ 1.   0.   0. ]</span>
<span class="go"> [ 0.5  0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">[[ 0.   0.   0. ]</span>
<span class="go"> [ 1.   0.   0. ]</span>
<span class="go"> [ 0.   1.   0. ]</span>
<span class="go"> [ 1.   1.   0. ]</span>
<span class="go"> [ 0.5  0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]</span>
<span class="go"> [ 0.5  1.   0. ]</span>
<span class="go"> [ 1.5  1.   0. ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>atoms=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reversed geometry</p>
<p>Also enables reversing a subset</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>angle</em>, <em>v</em>, <em>only='abc+xyz'</em>, <em>degree=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates the geometry, in-place by the angle around the vector</p>
<p>Per default will the entire geometry be rotated, such that everything
is aligned as before rotation.</p>
<p>However, by supplying <code class="docutils literal"><span class="pre">only='abc|xyz'</span></code> one can designate which
part of the geometry that will be rotated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>angle</strong> : float</p>
<blockquote>
<div><p>the angle in radians of which the geometry should be rotated</p>
</div></blockquote>
<p><strong>v</strong> : array_like [3]</p>
<blockquote>
<div><p>the vector around the rotation is going to happen
v = [1,0,0] will rotate in the <code class="docutils literal"><span class="pre">yz</span></code> plane</p>
</div></blockquote>
<p><strong>only</strong> : (&#8216;abc+xyz&#8217;), str, optional</p>
<blockquote class="last">
<div><p>which coordinate subject should be rotated,
if <code class="docutils literal"><span class="pre">abc</span></code> is in this string the cell will be rotated
if <code class="docutils literal"><span class="pre">xyz</span></code> is in this string the coordinates will be rotated</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.rotate_miller">
<code class="descname">rotate_miller</code><span class="sig-paren">(</span><em>m</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.rotate_miller" title="Permalink to this definition">¶</a></dt>
<dd><p>Align Miller direction along <code class="docutils literal"><span class="pre">v</span></code></p>
<p>Rotate geometry and cell such that the Miller direction
points along the Cartesian vector <code class="docutils literal"><span class="pre">v</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.rotatea">
<code class="descname">rotatea</code><span class="sig-paren">(</span><em>angle</em>, <em>only='abc+xyz'</em>, <em>degree=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.rotatea" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.rotateb">
<code class="descname">rotateb</code><span class="sig-paren">(</span><em>angle</em>, <em>only='abc+xyz'</em>, <em>degree=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.rotateb" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.rotatec">
<code class="descname">rotatec</code><span class="sig-paren">(</span><em>angle</em>, <em>only='abc+xyz'</em>, <em>degree=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.rotatec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.sc2uc">
<code class="descname">sc2uc</code><span class="sig-paren">(</span><em>atoms</em>, <em>uniq=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.sc2uc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns atoms from super-cell indices to unit-cell indices, possibly removing dublicates</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.sub">
<code class="descname">sub</code><span class="sig-paren">(</span><em>atoms</em>, <em>cell=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a subset of atoms from the geometry.</p>
<p>Indices passed <em>MUST</em> be unique.</p>
<p>Negative indices are wrapped and thus works.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atoms</strong> : array_like</p>
<blockquote>
<div><p>indices of all atoms to be removed.</p>
</div></blockquote>
<p><strong>cell</strong> : (<code class="docutils literal"><span class="pre">self.cell</span></code>), array_like, optional</p>
<blockquote class="last">
<div><p>the new associated cell of the geometry</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.swap">
<code class="descname">swap</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a geometry with swapped atoms</p>
<p>This can be used to reorder elements of a geometry.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.swapaxes">
<code class="descname">swapaxes</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>swap='cell+xyz'</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns geometry with swapped axis</p>
<p>If <code class="docutils literal"><span class="pre">swapaxes(0,1)</span></code> it returns the 0 and 1 values
swapped in the <code class="docutils literal"><span class="pre">cell</span></code> variable.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.tile">
<code class="descname">tile</code><span class="sig-paren">(</span><em>reps</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a geometry tiled, i.e. copied.</p>
<p>The atomic indices are retained for the base structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reps</strong> : number of tiles (repetitions)</p>
<p><strong>axis</strong> : direction of tiling</p>
<blockquote class="last">
<div><p>0, 1, 2 according to the cell-direction</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">]],</span><span class="n">xyz</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">[[ 0.   0.   0. ]</span>
<span class="go"> [ 0.5  0.   0. ]</span>
<span class="go"> [ 1.   0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">[[ 0.   0.   0. ]</span>
<span class="go"> [ 0.5  0.   0. ]</span>
<span class="go"> [ 1.   0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]</span>
<span class="go"> [ 0.   1.   0. ]</span>
<span class="go"> [ 0.5  1.   0. ]</span>
<span class="go"> [ 1.   1.   0. ]</span>
<span class="go"> [ 1.5  1.   0. ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.toASE">
<code class="descname">toASE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.toASE" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the geometry as an ASE <code class="docutils literal"><span class="pre">Atoms</span></code> object</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>v</em>, <em>atoms=None</em>, <em>cell=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates the geometry by <code class="docutils literal"><span class="pre">v</span></code></p>
<p>One can translate a subset of the atoms by supplying <code class="docutils literal"><span class="pre">atoms</span></code>.</p>
<p>Returns a copy of the structure translated by <code class="docutils literal"><span class="pre">v</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>sile</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes geometry to the <a class="reference internal" href="sisl.io.html#sisl.io.Sile" title="sisl.io.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> using <code class="xref any docutils literal"><span class="pre">sile.write_geom</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sile</strong> : Sile, str</p>
<blockquote>
<div><p>a <a class="reference internal" href="sisl.io.html#sisl.io.Sile" title="sisl.io.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> object which will be used to write the geometry
if it is a string it will create a new sile using <a class="reference internal" href="sisl.io.html#sisl.io.get_sile" title="sisl.io.get_sile"><code class="xref any py py-func docutils literal"><span class="pre">get_sile</span></code></a></p>
</div></blockquote>
<p><strong>*args, **kwargs: Any other args will be passed directly to the</strong></p>
<blockquote class="last">
<div><p>underlying routine</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


      </div>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Nick R. Papior.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>