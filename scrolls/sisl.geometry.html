<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sisl.geometry module &#8212; sisl |release| documentation</title>
    
    <link rel="stylesheet" href="_static/scrolls.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'v0.8.1
',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="sisl |release| documentation" href="index.html" /> 
  </head>
  <body role="document">
    <div id="content">
      <div class="header">
        <h1 class="heading"><a href="index.html"
          title="back to the documentation overview"><span>sisl.geometry module</span></a></h1>
      </div>
      <div class="relnav" role="navigation" aria-label="related navigation">
        <a href="#">sisl.geometry module</a>
      </div>
      <div id="contentwrapper">
        
  <div class="section" id="module-sisl.geometry">
<span id="sisl-geometry-module"></span><h1>sisl.geometry module<a class="headerlink" href="#module-sisl.geometry" title="Permalink to this headline">¶</a></h1>
<p>Geometry class to retain the atomic structure.</p>
<dl class="class">
<dt id="sisl.geometry.Geometry">
<em class="property">class </em><code class="descclassname">sisl.geometry.</code><code class="descname">Geometry</code><span class="sig-paren">(</span><em>xyz</em>, <em>atom=None</em>, <em>sc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCellChild" title="sisl.supercell.SuperCellChild"><code class="xref py py-class docutils literal"><span class="pre">sisl.supercell.SuperCellChild</span></code></a></p>
<p>Holds atomic information, coordinates, species, lattice vectors</p>
<p>The <a class="reference internal" href="#sisl.geometry.Geometry" title="sisl.geometry.Geometry"><code class="xref any py py-class docutils literal"><span class="pre">Geometry</span></code></a> class holds information regarding atomic coordinates,
the atomic species, the corresponding lattice-vectors.</p>
<p>It enables the interaction and conversion of atomic structures via
simple routine methods.</p>
<p>All lengths are assumed to be in units of Angstrom, however, as
long as units are kept same the exact units are irrespective.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz</strong> : array_like</p>
<blockquote>
<div><p>atomic coordinates
<code class="docutils literal"><span class="pre">xyz[i,:]</span></code> is the atomic coordinate of the i&#8217;th atom.</p>
</div></blockquote>
<p><strong>atom</strong> : array_like</p>
<blockquote>
<div><p>atomic species retrieved from the <a class="reference internal" href="sisl.atom.html#sisl.atom.PeriodicTable" title="sisl.atom.PeriodicTable"><code class="xref any py py-class docutils literal"><span class="pre">PeriodicTable</span></code></a></p>
</div></blockquote>
<p><strong>sc</strong> : <a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a></p>
<blockquote class="last">
<div><p>the unit-cell describing the atoms in a periodic
super-cell</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>An atomic lattice consisting of Hydrogen atoms.
An atomic square lattice of Hydrogen atoms</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">           [1, 1, 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="n">Atom</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">],</span><span class="n">sc</span><span class="p">)</span>
</pre></div>
</div>
<p>The following estimates the lattice vectors from the
atomic coordinates, although possible, it is not recommended
to be used.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">           [1, 1, 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="n">Atom</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.atom" title="sisl.geometry.Geometry.atom"><code class="xref py py-obj docutils literal"><span class="pre">atom</span></code></a></td>
<td>Retrieve the atoms for the geometry (<a class="reference internal" href="sisl.atom.html#sisl.atom.Atoms" title="sisl.atom.Atoms"><code class="xref any py py-class docutils literal"><span class="pre">Atoms</span></code></a> object)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.dR" title="sisl.geometry.Geometry.dR"><code class="xref py py-obj docutils literal"><span class="pre">dR</span></code></a></td>
<td>Returns the maximum orbital range of the atoms</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>na</td>
<td>(int) number of atoms, <code class="docutils literal"><span class="pre">len(self)</span></code></td>
</tr>
<tr class="row-even"><td>xyz</td>
<td>(ndarray) atomic coordinates</td>
</tr>
<tr class="row-odd"><td>sc</td>
<td>(<a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a>) the supercell describing the periodicity of the geometry</td>
</tr>
<tr class="row-even"><td>no: int</td>
<td>total number of orbitals in the geometry</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.ArgumentParser" title="sisl.geometry.Geometry.ArgumentParser"><code class="xref py py-obj docutils literal"><span class="pre">ArgumentParser</span></code></a>([parser])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.a2isc" title="sisl.geometry.Geometry.a2isc"><code class="xref py py-obj docutils literal"><span class="pre">a2isc</span></code></a>(a)</td>
<td>Returns the super-cell index for a specific/list atom</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.a2o" title="sisl.geometry.Geometry.a2o"><code class="xref py py-obj docutils literal"><span class="pre">a2o</span></code></a>(ia[,&nbsp;all])</td>
<td>Returns an orbital index of the first orbital of said atom.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.a2sc" title="sisl.geometry.Geometry.a2sc"><code class="xref py py-obj docutils literal"><span class="pre">a2sc</span></code></a>(a)</td>
<td>Returns the super-cell offset for a specific atom</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.add" title="sisl.geometry.Geometry.add"><code class="xref py py-obj docutils literal"><span class="pre">add</span></code></a>(other)</td>
<td>Adds atoms (as is) from the <code class="docutils literal"><span class="pre">other</span></code> geometry.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.append" title="sisl.geometry.Geometry.append"><code class="xref py py-obj docutils literal"><span class="pre">append</span></code></a>(other,&nbsp;axis)</td>
<td>Appends structure along <code class="docutils literal"><span class="pre">axis</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.asc2uc" title="sisl.geometry.Geometry.asc2uc"><code class="xref py py-obj docutils literal"><span class="pre">asc2uc</span></code></a>(atom[,&nbsp;uniq])</td>
<td>Returns atom from super-cell indices to unit-cell indices, possibly removing dublicates</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.attach" title="sisl.geometry.Geometry.attach"><code class="xref py py-obj docutils literal"><span class="pre">attach</span></code></a>(s_idx,&nbsp;other,&nbsp;o_idx[,&nbsp;dist,&nbsp;axis])</td>
<td>Attaches another <code class="docutils literal"><span class="pre">Geometry</span></code> at the <code class="xref any docutils literal"><span class="pre">s_idx</span></code> index with respect to <code class="xref any docutils literal"><span class="pre">o_idx</span></code> using different methods.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.axyzsc" title="sisl.geometry.Geometry.axyzsc"><code class="xref py py-obj docutils literal"><span class="pre">axyzsc</span></code></a>(ia)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.bond_correct" title="sisl.geometry.Geometry.bond_correct"><code class="xref py py-obj docutils literal"><span class="pre">bond_correct</span></code></a>(ia,&nbsp;atom[,&nbsp;method])</td>
<td>Corrects the bond between <code class="xref any docutils literal"><span class="pre">ia</span></code> and the <a class="reference internal" href="#sisl.geometry.Geometry.atom" title="sisl.geometry.Geometry.atom"><code class="xref any py py-attr docutils literal"><span class="pre">atom</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.center" title="sisl.geometry.Geometry.center"><code class="xref py py-obj docutils literal"><span class="pre">center</span></code></a>([atom,&nbsp;which])</td>
<td>Returns the center of the geometry</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.close" title="sisl.geometry.Geometry.close"><code class="xref py py-obj docutils literal"><span class="pre">close</span></code></a>(xyz_ia[,&nbsp;dR,&nbsp;idx,&nbsp;idx_xyz,&nbsp;ret_coord,&nbsp;...])</td>
<td>Returns supercell atomic indices for all atoms connecting to <code class="docutils literal"><span class="pre">xyz_ia</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.close_all" title="sisl.geometry.Geometry.close_all"><code class="xref py py-obj docutils literal"><span class="pre">close_all</span></code></a>(xyz_ia[,&nbsp;dR,&nbsp;idx,&nbsp;idx_xyz,&nbsp;...])</td>
<td>Returns supercell atomic indices for all atoms connecting to <code class="docutils literal"><span class="pre">xyz_ia</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.close_sc" title="sisl.geometry.Geometry.close_sc"><code class="xref py py-obj docutils literal"><span class="pre">close_sc</span></code></a>(xyz_ia[,&nbsp;isc,&nbsp;dR,&nbsp;idx,&nbsp;idx_xyz,&nbsp;...])</td>
<td>Calculates which atoms are close to some atom or point in space, only returns so relative to a super-cell.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.coords" title="sisl.geometry.Geometry.coords"><code class="xref py py-obj docutils literal"><span class="pre">coords</span></code></a>([isc,&nbsp;idx])</td>
<td>Returns the coordinates of a given super-cell index</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.copy" title="sisl.geometry.Geometry.copy"><code class="xref py py-obj docutils literal"><span class="pre">copy</span></code></a>()</td>
<td>Returns a copy of the object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.cut" title="sisl.geometry.Geometry.cut"><code class="xref py py-obj docutils literal"><span class="pre">cut</span></code></a>(seps,&nbsp;axis[,&nbsp;seg,&nbsp;rtol,&nbsp;atol])</td>
<td>Returns a subset of atoms from the geometry by cutting the geometry into <code class="docutils literal"><span class="pre">seps</span></code> parts along the direction <code class="docutils literal"><span class="pre">axis</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.fromASE" title="sisl.geometry.Geometry.fromASE"><code class="xref py py-obj docutils literal"><span class="pre">fromASE</span></code></a>(aseg)</td>
<td>Returns geometry from an ASE object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.iR" title="sisl.geometry.Geometry.iR"><code class="xref py py-obj docutils literal"><span class="pre">iR</span></code></a>([na,&nbsp;iR,&nbsp;dR])</td>
<td>Return an integer number of maximum radii (<code class="xref any docutils literal"><span class="pre">self.dR</span></code>) which holds approximately <a class="reference internal" href="sisl.io.siesta.html#sisl.io.siesta.tbtncSileSiesta.na" title="sisl.io.siesta.tbtncSileSiesta.na"><code class="xref any py py-attr docutils literal"><span class="pre">na</span></code></a> atoms</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.insert" title="sisl.geometry.Geometry.insert"><code class="xref py py-obj docutils literal"><span class="pre">insert</span></code></a>(atom,&nbsp;geom)</td>
<td>Inserts other atoms right before index</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">is_orthogonal</span></code>()</td>
<td>Return true if all cell vectors are linearly independent</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.iter_block" title="sisl.geometry.Geometry.iter_block"><code class="xref py py-obj docutils literal"><span class="pre">iter_block</span></code></a>([iR,&nbsp;dR,&nbsp;atom,&nbsp;method])</td>
<td>Returns an iterator for performance critical looping.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.iter_block_rand" title="sisl.geometry.Geometry.iter_block_rand"><code class="xref py py-obj docutils literal"><span class="pre">iter_block_rand</span></code></a>([iR,&nbsp;dR,&nbsp;atom])</td>
<td>Perform the <em>random</em> block-iteration by randomly selecting the next center of block</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.iter_block_shape" title="sisl.geometry.Geometry.iter_block_shape"><code class="xref py py-obj docutils literal"><span class="pre">iter_block_shape</span></code></a>([shape,&nbsp;iR,&nbsp;atom])</td>
<td>Perform the <em>grid</em> block-iteration by looping a grid</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.iter_linear" title="sisl.geometry.Geometry.iter_linear"><code class="xref py py-obj docutils literal"><span class="pre">iter_linear</span></code></a>()</td>
<td>Returns an iterator for simple linear ranges.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.iter_species" title="sisl.geometry.Geometry.iter_species"><code class="xref py py-obj docutils literal"><span class="pre">iter_species</span></code></a>()</td>
<td>Returns an iterator over all atoms and species as a tuple in this geometry</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.mirror" title="sisl.geometry.Geometry.mirror"><code class="xref py py-obj docutils literal"><span class="pre">mirror</span></code></a>(plane[,&nbsp;atom])</td>
<td>Mirrors the structure around the center of the atoms</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.move" title="sisl.geometry.Geometry.move"><code class="xref py py-obj docutils literal"><span class="pre">move</span></code></a>(v[,&nbsp;atom,&nbsp;cell])</td>
<td>Translates the geometry by <code class="docutils literal"><span class="pre">v</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.o2a" title="sisl.geometry.Geometry.o2a"><code class="xref py py-obj docutils literal"><span class="pre">o2a</span></code></a>(io)</td>
<td>Returns an atomic index corresponding to the orbital indicies.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.o2isc" title="sisl.geometry.Geometry.o2isc"><code class="xref py py-obj docutils literal"><span class="pre">o2isc</span></code></a>(o)</td>
<td>Returns the super-cell index for a specific orbital.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.o2sc" title="sisl.geometry.Geometry.o2sc"><code class="xref py py-obj docutils literal"><span class="pre">o2sc</span></code></a>(o)</td>
<td>Returns the super-cell offset for a specific orbital.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.osc2uc" title="sisl.geometry.Geometry.osc2uc"><code class="xref py py-obj docutils literal"><span class="pre">osc2uc</span></code></a>(orbs[,&nbsp;uniq])</td>
<td>Returns orbitals from super-cell indices to unit-cell indices, possibly removing dublicates</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.prepend" title="sisl.geometry.Geometry.prepend"><code class="xref py py-obj docutils literal"><span class="pre">prepend</span></code></a>(other,&nbsp;axis)</td>
<td>Prepends structure along <code class="docutils literal"><span class="pre">axis</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.read" title="sisl.geometry.Geometry.read"><code class="xref py py-obj docutils literal"><span class="pre">read</span></code></a>(sile)</td>
<td>Reads geometry from the <a class="reference internal" href="sisl.io.sile.html#sisl.io.sile.Sile" title="sisl.io.sile.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> using <code class="xref any docutils literal"><span class="pre">Sile.read_geom</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.remove" title="sisl.geometry.Geometry.remove"><code class="xref py py-obj docutils literal"><span class="pre">remove</span></code></a>(atom)</td>
<td>Remove atom from the geometry.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.repeat" title="sisl.geometry.Geometry.repeat"><code class="xref py py-obj docutils literal"><span class="pre">repeat</span></code></a>(reps,&nbsp;axis)</td>
<td>Returns a geometry repeated, i.e.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.reverse" title="sisl.geometry.Geometry.reverse"><code class="xref py py-obj docutils literal"><span class="pre">reverse</span></code></a>([atom])</td>
<td>Returns a reversed geometry</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.rotate" title="sisl.geometry.Geometry.rotate"><code class="xref py py-obj docutils literal"><span class="pre">rotate</span></code></a>(angle,&nbsp;v[,&nbsp;only,&nbsp;radians])</td>
<td>Rotates the geometry, in-place by the angle around the vector</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.rotate_miller" title="sisl.geometry.Geometry.rotate_miller"><code class="xref py py-obj docutils literal"><span class="pre">rotate_miller</span></code></a>(m,&nbsp;v)</td>
<td>Align Miller direction along <code class="docutils literal"><span class="pre">v</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.rotatea" title="sisl.geometry.Geometry.rotatea"><code class="xref py py-obj docutils literal"><span class="pre">rotatea</span></code></a>(angle[,&nbsp;only,&nbsp;radians])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.rotateb" title="sisl.geometry.Geometry.rotateb"><code class="xref py py-obj docutils literal"><span class="pre">rotateb</span></code></a>(angle[,&nbsp;only,&nbsp;radians])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.rotatec" title="sisl.geometry.Geometry.rotatec"><code class="xref py py-obj docutils literal"><span class="pre">rotatec</span></code></a>(angle[,&nbsp;only,&nbsp;radians])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.sc2uc" title="sisl.geometry.Geometry.sc2uc"><code class="xref py py-obj docutils literal"><span class="pre">sc2uc</span></code></a>(atom[,&nbsp;uniq])</td>
<td>Returns atom from super-cell indices to unit-cell indices, possibly removing dublicates</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">sc_index</span></code>(\*args,&nbsp;\*\*kwargs)</td>
<td>Call local <a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a> object <a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCellChild.sc_index" title="sisl.supercell.SuperCellChild.sc_index"><code class="xref any py py-meth docutils literal"><span class="pre">sc_index</span></code></a> function</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_nsc</span></code>(nsc)</td>
<td>Set the number of super-cells in the <a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a> object</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">set_sc</span></code>(sc)</td>
<td>Overwrites the local supercell</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">set_supercell</span></code>(sc)</td>
<td>Overwrites the local supercell</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.sub" title="sisl.geometry.Geometry.sub"><code class="xref py py-obj docutils literal"><span class="pre">sub</span></code></a>(atom[,&nbsp;cell])</td>
<td>Returns a subset of atoms from the geometry.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.swap" title="sisl.geometry.Geometry.swap"><code class="xref py py-obj docutils literal"><span class="pre">swap</span></code></a>(a,&nbsp;b)</td>
<td>Returns a geometry with swapped atoms</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.swapaxes" title="sisl.geometry.Geometry.swapaxes"><code class="xref py py-obj docutils literal"><span class="pre">swapaxes</span></code></a>(a,&nbsp;b[,&nbsp;swap])</td>
<td>Returns geometry with swapped axis</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.tile" title="sisl.geometry.Geometry.tile"><code class="xref py py-obj docutils literal"><span class="pre">tile</span></code></a>(reps,&nbsp;axis)</td>
<td>Returns a geometry tiled, i.e.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.toASE" title="sisl.geometry.Geometry.toASE"><code class="xref py py-obj docutils literal"><span class="pre">toASE</span></code></a>()</td>
<td>Returns the geometry as an ASE <code class="docutils literal"><span class="pre">Atoms</span></code> object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.translate" title="sisl.geometry.Geometry.translate"><code class="xref py py-obj docutils literal"><span class="pre">translate</span></code></a>(v[,&nbsp;atom,&nbsp;cell])</td>
<td>Translates the geometry by <code class="docutils literal"><span class="pre">v</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.within" title="sisl.geometry.Geometry.within"><code class="xref py py-obj docutils literal"><span class="pre">within</span></code></a>(shapes[,&nbsp;idx,&nbsp;idx_xyz,&nbsp;ret_coord,&nbsp;...])</td>
<td>Returns supercell atomic indices for all atoms connecting to <code class="docutils literal"><span class="pre">xyz_ia</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.geometry.Geometry.within_sc" title="sisl.geometry.Geometry.within_sc"><code class="xref py py-obj docutils literal"><span class="pre">within_sc</span></code></a>(shapes[,&nbsp;isc,&nbsp;idx,&nbsp;idx_xyz,&nbsp;...])</td>
<td>Calculates which atoms are close to some atom or point in space, only returns so relative to a super-cell.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.geometry.Geometry.write" title="sisl.geometry.Geometry.write"><code class="xref py py-obj docutils literal"><span class="pre">write</span></code></a>(sile,&nbsp;\*args,&nbsp;\*\*kwargs)</td>
<td>Writes geometry to the <a class="reference internal" href="sisl.io.sile.html#sisl.io.sile.Sile" title="sisl.io.sile.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> using <code class="xref any docutils literal"><span class="pre">sile.write_geom</span></code></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sisl.geometry.Geometry.ArgumentParser">
<code class="descname">ArgumentParser</code><span class="sig-paren">(</span><em>parser=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.ArgumentParser" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.a2isc">
<code class="descname">a2isc</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.a2isc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the super-cell index for a specific/list atom</p>
<p>Returns a vector of 3 numbers with integers.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.a2o">
<code class="descname">a2o</code><span class="sig-paren">(</span><em>ia</em>, <em>all=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.a2o" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an orbital index of the first orbital of said atom.
This is particularly handy if you want to create
TB models with more than one orbital per atom.</p>
<p>Note that this will preserve the super-cell offsets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ia</strong> : <code class="xref any docutils literal"><span class="pre">list</span></code> of <code class="xref any docutils literal"><span class="pre">int</span></code></p>
<blockquote>
<div><p>Atomic indices</p>
</div></blockquote>
<p><strong>all</strong> : <code class="xref any docutils literal"><span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></code></p>
<blockquote class="last">
<div><p><code class="xref any docutils literal"><span class="pre">False</span></code>, return only the first orbital corresponding to the atom,
<code class="xref any docutils literal"><span class="pre">True</span></code>, returns list of the full atom</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.a2sc">
<code class="descname">a2sc</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.a2sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the super-cell offset for a specific atom</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds atoms (as is) from the <code class="docutils literal"><span class="pre">other</span></code> geometry.
This will not alter the residing cell vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>other</strong> : <a class="reference internal" href="#sisl.geometry.Geometry" title="sisl.geometry.Geometry"><code class="xref any py py-class docutils literal"><span class="pre">Geometry</span></code></a></p>
<blockquote class="last">
<div><p>Other geometry class which is added</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>other</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends structure along <code class="docutils literal"><span class="pre">axis</span></code>. This will automatically
add the <code class="docutils literal"><span class="pre">self.cell[axis,:]</span></code> to all atomic coordiates in the
<code class="docutils literal"><span class="pre">other</span></code> structure before appending.</p>
<p>The basic algorithm is this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oxa</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:][</span><span class="kc">None</span><span class="p">,:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span><span class="n">oxa</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">lasto</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">lasto</span><span class="p">)</span>
</pre></div>
</div>
<p>NOTE: The cell appended is only in the axis that
is appended, which means that the other cell directions
need not conform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>other</strong> : <a class="reference internal" href="#sisl.geometry.Geometry" title="sisl.geometry.Geometry"><code class="xref any py py-class docutils literal"><span class="pre">Geometry</span></code></a>/<a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a></p>
<blockquote>
<div><p>Other geometry class which needs to be appended
If a <a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a> only the super cell will be extended</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote class="last">
<div><p>Cell direction to which the <code class="docutils literal"><span class="pre">other</span></code> geometry should be
appended.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.asc2uc">
<code class="descname">asc2uc</code><span class="sig-paren">(</span><em>atom</em>, <em>uniq=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.asc2uc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns atom from super-cell indices to unit-cell indices, possibly removing dublicates</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.geometry.Geometry.atom">
<code class="descname">atom</code><a class="headerlink" href="#sisl.geometry.Geometry.atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the atoms for the geometry (<a class="reference internal" href="sisl.atom.html#sisl.atom.Atoms" title="sisl.atom.Atoms"><code class="xref any py py-class docutils literal"><span class="pre">Atoms</span></code></a> object)</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.geometry.Geometry.atoms">
<code class="descname">atoms</code><a class="headerlink" href="#sisl.geometry.Geometry.atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the atoms for the geometry (<a class="reference internal" href="sisl.atom.html#sisl.atom.Atoms" title="sisl.atom.Atoms"><code class="xref any py py-class docutils literal"><span class="pre">Atoms</span></code></a> object)</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.attach">
<code class="descname">attach</code><span class="sig-paren">(</span><em>s_idx</em>, <em>other</em>, <em>o_idx</em>, <em>dist='calc'</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Attaches another <code class="docutils literal"><span class="pre">Geometry</span></code> at the <code class="xref any docutils literal"><span class="pre">s_idx</span></code> index with respect to <code class="xref any docutils literal"><span class="pre">o_idx</span></code> using different methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dist</strong> : <code class="xref any docutils literal"><span class="pre">arraylike</span></code>/<code class="xref any docutils literal"><span class="pre">float</span></code>/<code class="xref any docutils literal"><span class="pre">str</span></code>, <code class="xref any docutils literal"><span class="pre">'calc'</span></code></p>
<blockquote>
<div><p>the distance (in <code class="xref any docutils literal"><span class="pre">Ang</span></code>) between the attached coordinates. 
If <code class="xref any docutils literal"><span class="pre">dist</span></code> is <code class="xref any docutils literal"><span class="pre">arraylike</span> <span class="pre">it</span> <span class="pre">should</span> <span class="pre">be</span> <span class="pre">the</span> <span class="pre">vector</span> <span class="pre">between</span>
<span class="pre">the</span> <span class="pre">atoms;</span>
<span class="pre">if</span> <span class="pre">`dist</span></code> is <code class="xref any docutils literal"><span class="pre">float</span></code> the argument <code class="xref any docutils literal"><span class="pre">axis</span></code> is required
and the vector will be calculated along the corresponding latticevector;
else if <code class="xref any docutils literal"><span class="pre">dist</span></code> is <code class="xref any docutils literal"><span class="pre">str</span></code> this will correspond to the
<code class="xref any docutils literal"><span class="pre">method</span></code> argument of the <code class="docutils literal"><span class="pre">Atom.radius</span></code> class of the two 
atoms. Here <code class="xref any docutils literal"><span class="pre">axis</span></code> is also required.</p>
</div></blockquote>
<p><strong>axis</strong> : <code class="xref any docutils literal"><span class="pre">int</span></code></p>
<blockquote class="last">
<div><p>specify the direction of the lattice vectors used.
Not used if <code class="xref any docutils literal"><span class="pre">dist</span></code> is an array-like argument.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.axyzsc">
<code class="descname">axyzsc</code><span class="sig-paren">(</span><em>ia</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.axyzsc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.bond_correct">
<code class="descname">bond_correct</code><span class="sig-paren">(</span><em>ia</em>, <em>atom</em>, <em>method='calc'</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.bond_correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Corrects the bond between <code class="xref any docutils literal"><span class="pre">ia</span></code> and the <a class="reference internal" href="#sisl.geometry.Geometry.atom" title="sisl.geometry.Geometry.atom"><code class="xref any py py-attr docutils literal"><span class="pre">atom</span></code></a>.</p>
<p>Corrects the bond-length between atom <code class="xref any docutils literal"><span class="pre">ia</span></code> and <a class="reference internal" href="#sisl.geometry.Geometry.atom" title="sisl.geometry.Geometry.atom"><code class="xref any py py-attr docutils literal"><span class="pre">atom</span></code></a> in such
a way that the atomic radius is preserved.
I.e. the sum of the bond-lengths minimizes the distance matrix.</p>
<p>Only atom <code class="xref any docutils literal"><span class="pre">ia</span></code> is moved.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ia</strong> : int</p>
<blockquote>
<div><p>The atom to be displaced according to the atomic radius</p>
</div></blockquote>
<p><strong>atom</strong> : int, array_like</p>
<blockquote>
<div><p>The atom(s) from which the radius should be reduced.</p>
</div></blockquote>
<p><strong>method</strong> : str/float</p>
<blockquote class="last">
<div><p>If str will use that as lookup in <a class="reference internal" href="sisl.atom.html#sisl.atom.Atom.radius" title="sisl.atom.Atom.radius"><code class="xref any py py-meth docutils literal"><span class="pre">Atom.radius</span></code></a>.
Else it will be the new bond-length.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>atom=None</em>, <em>which='xyz'</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the center of the geometry</p>
<p>By specifying <code class="docutils literal"><span class="pre">which</span></code> one can control whether it should be:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">xyz|position</span></code>: Center of coordinates (default)</li>
<li><code class="docutils literal"><span class="pre">mass</span></code>: Center of mass</li>
<li><code class="docutils literal"><span class="pre">cell</span></code>: Center of cell</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : list, ndarray</p>
<blockquote>
<div><p>list of atomic indices to find center of</p>
</div></blockquote>
<p><strong>which</strong> : str</p>
<blockquote class="last">
<div><p>determine whether center should be of &#8216;cell&#8217;, mass-centered (&#8216;mass&#8217;),
or absolute center of the positions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.close">
<code class="descname">close</code><span class="sig-paren">(</span><em>xyz_ia</em>, <em>dR=None</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_coord=False</em>, <em>ret_dist=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns supercell atomic indices for all atoms connecting to <code class="docutils literal"><span class="pre">xyz_ia</span></code></p>
<p>This heavily relies on the <a class="reference internal" href="#sisl.geometry.Geometry.close_sc" title="sisl.geometry.Geometry.close_sc"><code class="xref any py py-meth docutils literal"><span class="pre">close_sc</span></code></a> method.</p>
<p>Note that if a connection is made in a neighbouring super-cell
then the atomic index is shifted by the super-cell index times
number of atoms.
This allows one to decipher super-cell atoms from unit-cell atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz_ia</strong> : coordinate/index</p>
<blockquote>
<div><p>Either a point in space or an index of an atom.
If an index is passed it is the equivalent of passing
the atomic coordinate <code class="xref any docutils literal"><span class="pre">close_sc(self.xyz[xyz_ia,:])</span></code>.</p>
</div></blockquote>
<p><strong>dR</strong> : (None), float/tuple of float</p>
<blockquote>
<div><p>The radii parameter to where the atomic connections are found.
If <code class="docutils literal"><span class="pre">dR</span></code> is an array it will return the indices:
in the ranges:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&gt;&gt;&gt; ``( x &lt;= dR[0] , dR[0] &lt; x &lt;= dR[1], dR[1] &lt; x &lt;= dR[2] )``
</pre></div>
</div>
<p>If a single float it will return:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&gt;&gt;&gt; ``x &lt;= dR``
</pre></div>
</div>
</div></blockquote>
<p><strong>idx</strong> : (None), array_like</p>
<blockquote>
<div><p>List of indices for atoms that are to be considered</p>
</div></blockquote>
<p><strong>idx_xyz</strong> : (None), array_like</p>
<blockquote>
<div><p>The atomic coordinates of the equivalent <code class="docutils literal"><span class="pre">idx</span></code> variable (<code class="docutils literal"><span class="pre">idx</span></code> must also be passed)</p>
</div></blockquote>
<p><strong>ret_coord</strong> : (False), boolean</p>
<blockquote>
<div><p>If true this method will return the coordinates
for each of the couplings.</p>
</div></blockquote>
<p><strong>ret_dist</strong> : (False), boolean</p>
<blockquote class="last">
<div><p>If true this method will return the distances from the <code class="docutils literal"><span class="pre">xyz_ia</span></code>
for each of the couplings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.close_all">
<code class="descname">close_all</code><span class="sig-paren">(</span><em>xyz_ia</em>, <em>dR=None</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_coord=False</em>, <em>ret_dist=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.close_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns supercell atomic indices for all atoms connecting to <code class="docutils literal"><span class="pre">xyz_ia</span></code></p>
<p>This heavily relies on the <a class="reference internal" href="#sisl.geometry.Geometry.close_sc" title="sisl.geometry.Geometry.close_sc"><code class="xref any py py-meth docutils literal"><span class="pre">close_sc</span></code></a> method.</p>
<p>Note that if a connection is made in a neighbouring super-cell
then the atomic index is shifted by the super-cell index times
number of atoms.
This allows one to decipher super-cell atoms from unit-cell atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz_ia</strong> : coordinate/index</p>
<blockquote>
<div><p>Either a point in space or an index of an atom.
If an index is passed it is the equivalent of passing
the atomic coordinate <code class="xref any docutils literal"><span class="pre">close_sc(self.xyz[xyz_ia,:])</span></code>.</p>
</div></blockquote>
<p><strong>dR</strong> : (None), float/tuple of float</p>
<blockquote>
<div><p>The radii parameter to where the atomic connections are found.
If <code class="docutils literal"><span class="pre">dR</span></code> is an array it will return the indices:
in the ranges:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&gt;&gt;&gt; ``( x &lt;= dR[0] , dR[0] &lt; x &lt;= dR[1], dR[1] &lt; x &lt;= dR[2] )``
</pre></div>
</div>
<p>If a single float it will return:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&gt;&gt;&gt; ``x &lt;= dR``
</pre></div>
</div>
</div></blockquote>
<p><strong>idx</strong> : (None), array_like</p>
<blockquote>
<div><p>List of indices for atoms that are to be considered</p>
</div></blockquote>
<p><strong>idx_xyz</strong> : (None), array_like</p>
<blockquote>
<div><p>The atomic coordinates of the equivalent <code class="docutils literal"><span class="pre">idx</span></code> variable (<code class="docutils literal"><span class="pre">idx</span></code> must also be passed)</p>
</div></blockquote>
<p><strong>ret_coord</strong> : (False), boolean</p>
<blockquote>
<div><p>If true this method will return the coordinates
for each of the couplings.</p>
</div></blockquote>
<p><strong>ret_dist</strong> : (False), boolean</p>
<blockquote class="last">
<div><p>If true this method will return the distances from the <code class="docutils literal"><span class="pre">xyz_ia</span></code>
for each of the couplings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.close_sc">
<code class="descname">close_sc</code><span class="sig-paren">(</span><em>xyz_ia</em>, <em>isc=None</em>, <em>dR=None</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_coord=False</em>, <em>ret_dist=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.close_sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates which atoms are close to some atom or point
in space, only returns so relative to a super-cell.</p>
<p>This returns a set of atomic indices which are within a
sphere of radius <code class="docutils literal"><span class="pre">dR</span></code>.</p>
<p>If dR is a tuple/list/array it will return the indices:
in the ranges:
&gt;&gt;&gt; ( x &lt;= dR[0] , dR[0] &lt; x &lt;= dR[1], dR[1] &lt; x &lt;= dR[2] )</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xyz_ia</strong> : coordinate/index</p>
<blockquote>
<div><p>Either a point in space or an index of an atom.
If an index is passed it is the equivalent of passing
the atomic coordinate <code class="docutils literal"><span class="pre">close_sc(self.xyz[xyz_ia,:])</span></code>.</p>
</div></blockquote>
<p><strong>isc</strong> : ([0,0,0]), array_like, optional</p>
<blockquote>
<div><p>The super-cell which the coordinates are checked in.</p>
</div></blockquote>
<p><strong>dR</strong> : (None), float/tuple of float</p>
<blockquote>
<div><p>The radii parameter to where the atomic connections are found.
If <code class="docutils literal"><span class="pre">dR</span></code> is an array it will return the indices:
in the ranges:</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">dR[0]</span> <span class="pre">,</span> <span class="pre">dR[0]</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">dR[1],</span> <span class="pre">dR[1]</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">dR[2]</span> <span class="pre">)</span></code></p>
</div></blockquote>
<dl class="docutils">
<dt>If a single float it will return:</dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">dR</span></code></p>
</dd>
</dl>
</div></blockquote>
<p><strong>idx</strong> : (None), array_like</p>
<blockquote>
<div><p>List of atoms that will be considered. This can
be used to only take out a certain atoms.</p>
</div></blockquote>
<p><strong>idx_xyz</strong> : (None), array_like</p>
<blockquote>
<div><p>The atomic coordinates of the equivalent <code class="docutils literal"><span class="pre">idx</span></code> variable (<code class="docutils literal"><span class="pre">idx</span></code> must also be passed)</p>
</div></blockquote>
<p><strong>ret_coord</strong> : (False), boolean</p>
<blockquote>
<div><p>If true this method will return the coordinates
for each of the couplings.</p>
</div></blockquote>
<p><strong>ret_dist</strong> : (False), boolean</p>
<blockquote class="last">
<div><p>If true this method will return the distance
for each of the couplings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.coords">
<code class="descname">coords</code><span class="sig-paren">(</span><em>isc=None</em>, <em>idx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coordinates of a given super-cell index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>isc</strong> : array_like, ([0,0,0])</p>
<blockquote>
<div><p>Returns the atomic coordinates shifted according to the integer
parts of the cell.</p>
</div></blockquote>
<p><strong>idx</strong> : int/array_like</p>
<blockquote class="last">
<div><p>Only return the coordinates of these indices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">]],</span><span class="n">xyz</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">isc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[[ 1.   0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the object.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.cut">
<code class="descname">cut</code><span class="sig-paren">(</span><em>seps</em>, <em>axis</em>, <em>seg=0</em>, <em>rtol=0.0001</em>, <em>atol=0.0001</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a subset of atoms from the geometry by cutting the
geometry into <code class="docutils literal"><span class="pre">seps</span></code> parts along the direction <code class="docutils literal"><span class="pre">axis</span></code>.
It will then _only_ return the first cut.</p>
<p>This will effectively change the unit-cell in the <code class="docutils literal"><span class="pre">axis</span></code> as-well
as removing <code class="docutils literal"><span class="pre">self.na/seps</span></code> atoms.
It requires that <code class="docutils literal"><span class="pre">self.na</span> <span class="pre">%</span> <span class="pre">seps</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p>
<p>REMARK: You need to ensure that all atoms within the first
cut out region are within the primary unit-cell.</p>
<p>Doing <code class="docutils literal"><span class="pre">geom.cut(2,1).tile(seps=2,axis=1)</span></code>, could for symmetric setups,
be equivalent to a no-op operation. A <code class="docutils literal"><span class="pre">UserWarning</span></code> will be issued
if this is not the case.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seps</strong> : int</p>
<blockquote>
<div><p>number of times the structure will be cut.</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote>
<div><p>the axis that will be cut</p>
</div></blockquote>
<p><strong>seg</strong> : int, optional (0)</p>
<blockquote>
<div><p>returns the i&#8217;th segment of the cut structure
Currently the atomic coordinates are not translated,
this may change in the future.</p>
</div></blockquote>
<p><strong>rtol</strong> : (tolerance for checking tiling, see <code class="docutils literal"><span class="pre">numpy.allclose</span></code>)</p>
<p class="last"><strong>atol</strong> : (tolerance for checking tiling, see <code class="docutils literal"><span class="pre">numpy.allclose</span></code>)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.geometry.Geometry.dR">
<code class="descname">dR</code><a class="headerlink" href="#sisl.geometry.Geometry.dR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum orbital range of the atoms</p>
</dd></dl>

<dl class="classmethod">
<dt id="sisl.geometry.Geometry.fromASE">
<em class="property">classmethod </em><code class="descname">fromASE</code><span class="sig-paren">(</span><em>aseg</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.fromASE" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns geometry from an ASE object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>aseg</strong> : ASE <code class="docutils literal"><span class="pre">Atoms</span></code> object which contains the following routines:</p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">get_atomic_numbers</span></code>, <code class="docutils literal"><span class="pre">get_positions</span></code>, <code class="docutils literal"><span class="pre">get_cell</span></code>.
From those methods a <a class="reference internal" href="sisl.html"><span class="doc">sisl package</span></a> object will be created.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.geometry.Geometry.fxyz">
<code class="descname">fxyz</code><a class="headerlink" href="#sisl.geometry.Geometry.fxyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns geometry coordinates in fractional coordinates</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.iR">
<code class="descname">iR</code><span class="sig-paren">(</span><em>na=1000</em>, <em>iR=20</em>, <em>dR=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.iR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an integer number of maximum radii (<code class="xref any docutils literal"><span class="pre">self.dR</span></code>) which holds approximately <a class="reference internal" href="sisl.io.siesta.html#sisl.io.siesta.tbtncSileSiesta.na" title="sisl.io.siesta.tbtncSileSiesta.na"><code class="xref any py py-attr docutils literal"><span class="pre">na</span></code></a> atoms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>na</strong> : <code class="docutils literal"><span class="pre">int</span></code></p>
<blockquote>
<div><p>number of atoms within the radius</p>
</div></blockquote>
<p><strong>iR</strong> : <code class="docutils literal"><span class="pre">int</span></code></p>
<blockquote>
<div><p>initial <code class="docutils literal"><span class="pre">iR</span></code> value, which the sphere is estitametd from</p>
</div></blockquote>
<p><strong>dR</strong> : <code class="docutils literal"><span class="pre">float</span></code></p>
<blockquote class="last">
<div><p>the value used for atomic range (defaults to <code class="docutils literal"><span class="pre">self.dR</span></code>)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>atom</em>, <em>geom</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts other atoms right before index</p>
<p>We insert the <code class="docutils literal"><span class="pre">geom</span></code> <a class="reference internal" href="#sisl.geometry.Geometry" title="sisl.geometry.Geometry"><code class="xref any py py-class docutils literal"><span class="pre">Geometry</span></code></a> before <a class="reference internal" href="#sisl.geometry.Geometry.atom" title="sisl.geometry.Geometry.atom"><code class="xref any py py-attr docutils literal"><span class="pre">atom</span></code></a>.
Note that this will not change the unit cell.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : int</p>
<blockquote>
<div><p>the index at which atom the other geometry is inserted</p>
</div></blockquote>
<p><strong>geom</strong> : <a class="reference internal" href="#sisl.geometry.Geometry" title="sisl.geometry.Geometry"><code class="xref any py py-class docutils literal"><span class="pre">Geometry</span></code></a></p>
<blockquote class="last">
<div><p>the other geometry to be inserted</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.iter_block">
<code class="descname">iter_block</code><span class="sig-paren">(</span><em>iR=10</em>, <em>dR=None</em>, <em>atom=None</em>, <em>method='rand'</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.iter_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator for performance critical looping.</p>
<p>NOTE: This requires that dR has been set correctly as the maximum interaction range.</p>
<p>I.e. the loop would look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">iter_block</span><span class="p">():</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ias</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="n">idx_a</span> <span class="o">=</span> <span class="n">dev</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">dR</span> <span class="o">=</span> <span class="n">dR</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">)</span>
</pre></div>
</div>
<p>This iterator is intended for systems with more than 1000 atoms.</p>
<p>Remark that the iterator used is non-deterministic, i.e. any two iterators need
not return the same atoms in any way.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : <code class="xref any docutils literal"><span class="pre">list,</span> <span class="pre">np.ndarray</span></code></p>
<blockquote>
<div><p>enables only effectively looping a subset of the full geometry</p>
</div></blockquote>
<p><strong>iR</strong> : <code class="xref any docutils literal"><span class="pre">int</span></code> (<code class="xref any docutils literal"><span class="pre">10</span></code>)</p>
<blockquote>
<div><p>the number of <code class="docutils literal"><span class="pre">dR</span></code> ranges taken into account when doing the iterator</p>
</div></blockquote>
<p><strong>dR</strong> : <code class="xref any docutils literal"><span class="pre">float</span></code>, (<code class="xref any docutils literal"><span class="pre">self.dR</span></code>)</p>
<blockquote>
<div><p>enables overwriting the local dR quantity.</p>
</div></blockquote>
<p><strong>method</strong> : <code class="xref any docutils literal"><span class="pre">str</span></code> (<code class="xref any docutils literal"><span class="pre">'rand'</span></code>)</p>
<blockquote>
<div><p>select the method by which the block iteration is performed. 
Possible values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="xref any docutils literal"><span class="pre">rand</span></code>: a spherical object is constructed with a random center according </dt>
<dd><p class="first last">to the internal atoms</p>
</dd>
</dl>
<p><a class="reference internal" href="sisl.grid.html#module-sisl.grid" title="sisl.grid"><code class="xref any py py-mod docutils literal"><span class="pre">grid</span></code></a>: a grid object is constructed and rigorously looped</p>
</div></blockquote>
</div></blockquote>
<p><strong>Returns two lists with [0] being a list of atoms to be looped and [1] being the atoms that</strong></p>
<p class="last"><strong>need searched.</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.iter_block_rand">
<code class="descname">iter_block_rand</code><span class="sig-paren">(</span><em>iR=10</em>, <em>dR=None</em>, <em>atom=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.iter_block_rand" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the <em>random</em> block-iteration by randomly selecting the next center of block</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.iter_block_shape">
<code class="descname">iter_block_shape</code><span class="sig-paren">(</span><em>shape=None</em>, <em>iR=10</em>, <em>atom=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.iter_block_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the <em>grid</em> block-iteration by looping a grid</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.iter_linear">
<code class="descname">iter_linear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.iter_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator for simple linear ranges.</p>
<p>This iterator is the same as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="o">&lt;</span><span class="n">do</span> <span class="n">something</span><span class="o">&gt;</span>
</pre></div>
</div>
<dl class="docutils">
<dt>or equivalently</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="o">&lt;</span><span class="n">do</span> <span class="n">something</span><span class="o">&gt;</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.iter_species">
<code class="descname">iter_species</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.iter_species" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over all atoms and species as a tuple in this geometry</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">idx_specie</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_species</span><span class="p">():</span>
</pre></div>
</div>
<p>with <code class="docutils literal"><span class="pre">ia</span></code> being the atomic index, <code class="docutils literal"><span class="pre">a</span></code> the <a class="reference internal" href="sisl.atom.html#sisl.atom.Atom" title="sisl.atom.Atom"><code class="xref any py py-class docutils literal"><span class="pre">Atom</span></code></a> object, <code class="xref any docutils literal"><span class="pre">idx_specie</span></code>
is the index of the species</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.geometry.Geometry.mass">
<code class="descname">mass</code><a class="headerlink" href="#sisl.geometry.Geometry.mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mass of all atoms as an array</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.mirror">
<code class="descname">mirror</code><span class="sig-paren">(</span><em>plane</em>, <em>atom=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Mirrors the structure around the center of the atoms</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.move">
<code class="descname">move</code><span class="sig-paren">(</span><em>v</em>, <em>atom=None</em>, <em>cell=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates the geometry by <code class="docutils literal"><span class="pre">v</span></code></p>
<p>One can translate a subset of the atoms by supplying <code class="docutils literal"><span class="pre">atom</span></code>.</p>
<p>Returns a copy of the structure translated by <code class="docutils literal"><span class="pre">v</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.geometry.Geometry.no_s">
<code class="descname">no_s</code><a class="headerlink" href="#sisl.geometry.Geometry.no_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of supercell orbitals</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.o2a">
<code class="descname">o2a</code><span class="sig-paren">(</span><em>io</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.o2a" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an atomic index corresponding to the orbital indicies.</p>
<p>This is a particurlaly slow algorithm due to for-loops.</p>
<p>Note that this will preserve the super-cell offsets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>io: `list` of `int`</strong></p>
<blockquote class="last">
<div><p>List of indices to return the atoms for</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.o2isc">
<code class="descname">o2isc</code><span class="sig-paren">(</span><em>o</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.o2isc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the super-cell index for a specific orbital.</p>
<p>Returns a vector of 3 numbers with integers.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.o2sc">
<code class="descname">o2sc</code><span class="sig-paren">(</span><em>o</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.o2sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the super-cell offset for a specific orbital.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.osc2uc">
<code class="descname">osc2uc</code><span class="sig-paren">(</span><em>orbs</em>, <em>uniq=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.osc2uc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns orbitals from super-cell indices to unit-cell indices, possibly removing dublicates</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.prepend">
<code class="descname">prepend</code><span class="sig-paren">(</span><em>other</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.prepend" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepends structure along <code class="docutils literal"><span class="pre">axis</span></code>. This will automatically
add the <code class="docutils literal"><span class="pre">self.cell[axis,:]</span></code> to all atomic coordiates in the
<code class="docutils literal"><span class="pre">other</span></code> structure before prepending.</p>
<p>The basic algorithm is this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oxa</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oxa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:][</span><span class="kc">None</span><span class="p">,:])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">lasto</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">lasto</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">)</span>
</pre></div>
</div>
<p>NOTE: The cell prepended is only in the axis that
is prependend, which means that the other cell directions
need not conform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>other</strong> : <a class="reference internal" href="#sisl.geometry.Geometry" title="sisl.geometry.Geometry"><code class="xref any py py-class docutils literal"><span class="pre">Geometry</span></code></a>/<a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a></p>
<blockquote>
<div><p>Other geometry class which needs to be prepended
If a <a class="reference internal" href="sisl.supercell.html#sisl.supercell.SuperCell" title="sisl.supercell.SuperCell"><code class="xref any py py-class docutils literal"><span class="pre">SuperCell</span></code></a> only the super cell will be extended</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote class="last">
<div><p>Cell direction to which the <code class="docutils literal"><span class="pre">other</span></code> geometry should be
prepended</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="sisl.geometry.Geometry.read">
<em class="property">static </em><code class="descname">read</code><span class="sig-paren">(</span><em>sile</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads geometry from the <a class="reference internal" href="sisl.io.sile.html#sisl.io.sile.Sile" title="sisl.io.sile.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> using <code class="xref any docutils literal"><span class="pre">Sile.read_geom</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sile</strong> : <a class="reference internal" href="sisl.io.sile.html#sisl.io.sile.Sile" title="sisl.io.sile.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a>, str</p>
<blockquote class="last">
<div><p>a <a class="reference internal" href="sisl.io.sile.html#sisl.io.sile.Sile" title="sisl.io.sile.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> object which will be used to read the geometry
if it is a string it will create a new sile using <a class="reference internal" href="sisl.io.html#sisl.io.get_sile" title="sisl.io.get_sile"><code class="xref any py py-func docutils literal"><span class="pre">get_sile</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>atom</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove atom from the geometry.</p>
<p>Indices passed <em>MUST</em> be unique.</p>
<p>Negative indices are wrapped and thus works.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : array_like</p>
<blockquote class="last">
<div><p>indices of all atoms to be removed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><em>reps</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a geometry repeated, i.e. copied in a special way.</p>
<p>The atomic indices are <em>NOT</em> retained for the base structure.</p>
<p>The expansion of the atoms are basically performed using this
algorithm:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ja</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="n">ja</span> <span class="o">=</span> <span class="n">ia</span> <span class="o">+</span> <span class="n">cell</span><span class="p">[</span><span class="nb">id</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">i</span>
</pre></div>
</div>
<p>This method allows to utilise Bloch&#8217;s theorem when creating
tight-binding parameter sets for TBtrans.</p>
<p>For geometries with a single atom this routine returns the same as
<a class="reference internal" href="#sisl.geometry.Geometry.tile" title="sisl.geometry.Geometry.tile"><code class="xref any py py-meth docutils literal"><span class="pre">tile</span></code></a>.</p>
<p>It is adviced to only use this for electrode Bloch&#8217;s theorem
purposes as <a class="reference internal" href="#sisl.geometry.Geometry.tile" title="sisl.geometry.Geometry.tile"><code class="xref any py py-meth docutils literal"><span class="pre">tile</span></code></a> is faster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reps</strong> : number of repetitions</p>
<p><strong>axis</strong> : direction of repetition</p>
<blockquote class="last">
<div><p>0, 1, 2 according to the cell-direction</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">]],</span><span class="n">xyz</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">[[ 0.   0.   0. ]</span>
<span class="go"> [ 1.   0.   0. ]</span>
<span class="go"> [ 0.5  0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">[[ 0.   0.   0. ]</span>
<span class="go"> [ 1.   0.   0. ]</span>
<span class="go"> [ 0.   1.   0. ]</span>
<span class="go"> [ 1.   1.   0. ]</span>
<span class="go"> [ 0.5  0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]</span>
<span class="go"> [ 0.5  1.   0. ]</span>
<span class="go"> [ 1.5  1.   0. ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>atom=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reversed geometry</p>
<p>Also enables reversing a subset of the atoms.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>angle</em>, <em>v</em>, <em>only='abc+xyz'</em>, <em>radians=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates the geometry, in-place by the angle around the vector</p>
<p>Per default will the entire geometry be rotated, such that everything
is aligned as before rotation.</p>
<p>However, by supplying <code class="docutils literal"><span class="pre">only='abc|xyz'</span></code> one can designate which
part of the geometry that will be rotated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>angle</strong> : float</p>
<blockquote>
<div><p>the angle in radians of which the geometry should be rotated</p>
</div></blockquote>
<p><strong>v</strong> : array_like [3]</p>
<blockquote>
<div><p>the vector around the rotation is going to happen
v = [1,0,0] will rotate in the <code class="docutils literal"><span class="pre">yz</span></code> plane</p>
</div></blockquote>
<p><strong>only</strong> : (&#8216;abc+xyz&#8217;), str, optional</p>
<blockquote class="last">
<div><p>which coordinate subject should be rotated,
if <code class="docutils literal"><span class="pre">abc</span></code> is in this string the cell will be rotated
if <code class="docutils literal"><span class="pre">xyz</span></code> is in this string the coordinates will be rotated</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.rotate_miller">
<code class="descname">rotate_miller</code><span class="sig-paren">(</span><em>m</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.rotate_miller" title="Permalink to this definition">¶</a></dt>
<dd><p>Align Miller direction along <code class="docutils literal"><span class="pre">v</span></code></p>
<p>Rotate geometry and cell such that the Miller direction
points along the Cartesian vector <code class="docutils literal"><span class="pre">v</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.rotatea">
<code class="descname">rotatea</code><span class="sig-paren">(</span><em>angle</em>, <em>only='abc+xyz'</em>, <em>radians=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.rotatea" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.rotateb">
<code class="descname">rotateb</code><span class="sig-paren">(</span><em>angle</em>, <em>only='abc+xyz'</em>, <em>radians=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.rotateb" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.rotatec">
<code class="descname">rotatec</code><span class="sig-paren">(</span><em>angle</em>, <em>only='abc+xyz'</em>, <em>radians=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.rotatec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.sc2uc">
<code class="descname">sc2uc</code><span class="sig-paren">(</span><em>atom</em>, <em>uniq=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.sc2uc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns atom from super-cell indices to unit-cell indices, possibly removing dublicates</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.sub">
<code class="descname">sub</code><span class="sig-paren">(</span><em>atom</em>, <em>cell=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a subset of atoms from the geometry.</p>
<p>Indices passed <em>MUST</em> be unique.</p>
<p>Negative indices are wrapped and thus works.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : array_like</p>
<blockquote>
<div><p>indices of all atoms to be removed.</p>
</div></blockquote>
<p><strong>cell</strong> : (<code class="docutils literal"><span class="pre">self.cell</span></code>), array_like, optional</p>
<blockquote class="last">
<div><p>the new associated cell of the geometry</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.swap">
<code class="descname">swap</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a geometry with swapped atoms</p>
<p>This can be used to reorder elements of a geometry.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.swapaxes">
<code class="descname">swapaxes</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>swap='cell+xyz'</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns geometry with swapped axis</p>
<p>If <code class="docutils literal"><span class="pre">swapaxes(0,1)</span></code> it returns the 0 and 1 values
swapped in the <code class="docutils literal"><span class="pre">cell</span></code> variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : int</p>
<blockquote>
<div><p>axes 1, swaps with <code class="docutils literal"><span class="pre">b</span></code></p>
</div></blockquote>
<p><strong>b</strong> : int</p>
<blockquote>
<div><p>axes 2, swaps with <code class="docutils literal"><span class="pre">a</span></code></p>
</div></blockquote>
<p><strong>swap</strong> : str, &#8220;cell+xyz&#8221;</p>
<blockquote class="last">
<div><p>decide what to swap, if <code class="xref any docutils literal"><span class="pre">&quot;cell&quot;</span></code> is in <a class="reference internal" href="#sisl.geometry.Geometry.swap" title="sisl.geometry.Geometry.swap"><code class="xref any py py-meth docutils literal"><span class="pre">swap</span></code></a> then
the cell axis are swapped.
if <code class="xref any docutils literal"><span class="pre">&quot;xyz&quot;</span></code> is in <a class="reference internal" href="#sisl.geometry.Geometry.swap" title="sisl.geometry.Geometry.swap"><code class="xref any py py-meth docutils literal"><span class="pre">swap</span></code></a> then
the xyz (Cartesian) axis are swapped.
Both may be in <a class="reference internal" href="#sisl.geometry.Geometry.swap" title="sisl.geometry.Geometry.swap"><code class="xref any py py-meth docutils literal"><span class="pre">swap</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.tile">
<code class="descname">tile</code><span class="sig-paren">(</span><em>reps</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a geometry tiled, i.e. copied.</p>
<p>The atomic indices are retained for the base structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reps</strong> : number of tiles (repetitions)</p>
<p><strong>axis</strong> : direction of tiling</p>
<blockquote class="last">
<div><p>0, 1, 2 according to the cell-direction</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">]],</span><span class="n">xyz</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">[[ 0.   0.   0. ]</span>
<span class="go"> [ 0.5  0.   0. ]</span>
<span class="go"> [ 1.   0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">[[ 0.   0.   0. ]</span>
<span class="go"> [ 0.5  0.   0. ]</span>
<span class="go"> [ 1.   0.   0. ]</span>
<span class="go"> [ 1.5  0.   0. ]</span>
<span class="go"> [ 0.   1.   0. ]</span>
<span class="go"> [ 0.5  1.   0. ]</span>
<span class="go"> [ 1.   1.   0. ]</span>
<span class="go"> [ 1.5  1.   0. ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.toASE">
<code class="descname">toASE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.toASE" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the geometry as an ASE <code class="docutils literal"><span class="pre">Atoms</span></code> object</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>v</em>, <em>atom=None</em>, <em>cell=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates the geometry by <code class="docutils literal"><span class="pre">v</span></code></p>
<p>One can translate a subset of the atoms by supplying <code class="docutils literal"><span class="pre">atom</span></code>.</p>
<p>Returns a copy of the structure translated by <code class="docutils literal"><span class="pre">v</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.within">
<code class="descname">within</code><span class="sig-paren">(</span><em>shapes</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_coord=False</em>, <em>ret_dist=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.within" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns supercell atomic indices for all atoms connecting to <code class="docutils literal"><span class="pre">xyz_ia</span></code></p>
<p>This heavily relies on the <a class="reference internal" href="#sisl.geometry.Geometry.close_sc" title="sisl.geometry.Geometry.close_sc"><code class="xref any py py-meth docutils literal"><span class="pre">close_sc</span></code></a> method.</p>
<p>Note that if a connection is made in a neighbouring super-cell
then the atomic index is shifted by the super-cell index times
number of atoms.
This allows one to decipher super-cell atoms from unit-cell atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shapes</strong> : <a class="reference internal" href="sisl.shape.shape.html#sisl.shape.shape.Shape" title="sisl.shape.shape.Shape"><code class="xref any py py-class docutils literal"><span class="pre">Shape</span></code></a>/<code class="xref any docutils literal"><span class="pre">list</span> <span class="pre">of</span> <span class="pre">Shape</span></code></p>
<p><strong>idx</strong> : (None), array_like</p>
<blockquote>
<div><p>List of indices for atoms that are to be considered</p>
</div></blockquote>
<p><strong>idx_xyz</strong> : (None), array_like</p>
<blockquote>
<div><p>The atomic coordinates of the equivalent <code class="docutils literal"><span class="pre">idx</span></code> variable (<code class="docutils literal"><span class="pre">idx</span></code> must also be passed)</p>
</div></blockquote>
<p><strong>ret_coord</strong> : (False), boolean</p>
<blockquote>
<div><p>If true this method will return the coordinates
for each of the couplings.</p>
</div></blockquote>
<p><strong>ret_dist</strong> : (False), boolean</p>
<blockquote class="last">
<div><p>If true this method will return the distances from the <code class="docutils literal"><span class="pre">xyz_ia</span></code>
for each of the couplings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.within_sc">
<code class="descname">within_sc</code><span class="sig-paren">(</span><em>shapes</em>, <em>isc=None</em>, <em>idx=None</em>, <em>idx_xyz=None</em>, <em>ret_coord=False</em>, <em>ret_dist=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.within_sc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates which atoms are close to some atom or point
in space, only returns so relative to a super-cell.</p>
<p>This returns a set of atomic indices which are within a
sphere of radius <code class="docutils literal"><span class="pre">dR</span></code>.</p>
<p>If dR is a tuple/list/array it will return the indices:
in the ranges:
&gt;&gt;&gt; ( x &lt;= dR[0] , dR[0] &lt; x &lt;= dR[1], dR[1] &lt; x &lt;= dR[2] )</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shapes</strong> : <a class="reference internal" href="sisl.shape.shape.html#sisl.shape.shape.Shape" title="sisl.shape.shape.Shape"><code class="xref any py py-class docutils literal"><span class="pre">Shape</span></code></a>/<code class="xref any docutils literal"><span class="pre">list</span> <span class="pre">of</span> <span class="pre">Shape</span></code></p>
<blockquote>
<div><p>A list of increasing shapes that define the extend of the geometric
volume that is searched.
It is vital that:</p>
<blockquote>
<div><p>shapes[0] in shapes[1] in shapes[2] ...</p>
</div></blockquote>
</div></blockquote>
<p><strong>isc</strong> : ([0,0,0]), array_like, optional</p>
<blockquote>
<div><p>The super-cell which the coordinates are checked in.</p>
</div></blockquote>
<p><strong>idx</strong> : (None), array_like</p>
<blockquote>
<div><p>List of atoms that will be considered. This can
be used to only take out a certain atoms.</p>
</div></blockquote>
<p><strong>idx_xyz</strong> : (None), array_like</p>
<blockquote>
<div><p>The atomic coordinates of the equivalent <code class="docutils literal"><span class="pre">idx</span></code> variable (<code class="docutils literal"><span class="pre">idx</span></code> must also be passed)</p>
</div></blockquote>
<p><strong>ret_coord</strong> : (False), boolean</p>
<blockquote>
<div><p>If true this method will return the coordinates
for each of the couplings.</p>
</div></blockquote>
<p><strong>ret_dist</strong> : (False), boolean</p>
<blockquote class="last">
<div><p>If true this method will return the distance
for each of the couplings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.geometry.Geometry.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>sile</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.Geometry.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes geometry to the <a class="reference internal" href="sisl.io.sile.html#sisl.io.sile.Sile" title="sisl.io.sile.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> using <code class="xref any docutils literal"><span class="pre">sile.write_geom</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sile</strong> : Sile, str</p>
<blockquote>
<div><p>a <a class="reference internal" href="sisl.io.sile.html#sisl.io.sile.Sile" title="sisl.io.sile.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> object which will be used to write the geometry
if it is a string it will create a new sile using <a class="reference internal" href="sisl.io.html#sisl.io.get_sile" title="sisl.io.get_sile"><code class="xref any py py-func docutils literal"><span class="pre">get_sile</span></code></a></p>
</div></blockquote>
<p><strong>*args, **kwargs: Any other args will be passed directly to the</strong></p>
<blockquote class="last">
<div><p>underlying routine</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sisl.geometry.sgeom">
<code class="descclassname">sisl.geometry.</code><code class="descname">sgeom</code><span class="sig-paren">(</span><em>geom=None</em>, <em>argv=None</em>, <em>ret_geometry=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.geometry.sgeom" title="Permalink to this definition">¶</a></dt>
<dd><p>Main script for sgeom script.</p>
<p>This routine may be called with <code class="xref any docutils literal"><span class="pre">argv</span></code> and/or a <a class="reference internal" href="sisl.io.sile.html#sisl.io.sile.Sile" title="sisl.io.sile.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> which is the geometry at hand.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>geom</strong> : <a class="reference internal" href="#sisl.geometry.Geometry" title="sisl.geometry.Geometry"><code class="xref any py py-class docutils literal"><span class="pre">Geometry</span></code></a>/<a class="reference internal" href="sisl.io.html#sisl.io.BaseSile" title="sisl.io.BaseSile"><code class="xref any py py-class docutils literal"><span class="pre">BaseSile</span></code></a></p>
<blockquote>
<div><p>this may either be the geometry, as-is, or a <a class="reference internal" href="sisl.io.sile.html#sisl.io.sile.Sile" title="sisl.io.sile.Sile"><code class="xref any py py-class docutils literal"><span class="pre">Sile</span></code></a> which contains
the geometry.</p>
</div></blockquote>
<p><strong>argv</strong> : <code class="xref any docutils literal"><span class="pre">list</span> <span class="pre">of</span> <span class="pre">str</span></code></p>
<blockquote>
<div><p>the arguments passed to sgeom</p>
</div></blockquote>
<p><strong>ret_geometry</strong> : <code class="xref any docutils literal"><span class="pre">bool</span></code> (<code class="xref any docutils literal"><span class="pre">False</span></code>)</p>
<blockquote class="last">
<div><p>whether the function should return the geometry</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


      </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, Nick R. Papior.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.8.
    </div>
  </body>
</html>